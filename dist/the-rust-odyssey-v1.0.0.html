<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Robin George Koshy" />
  <title>The Rust Odyssey: A C++ Developer's Journey</title>
  <style>
    /* Default styles provided by pandoc.
    ** See https://pandoc.org/MANUAL.html#variables-for-html for config info.
    */
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      border: none;
      border-top: 1px solid #1a1a1a;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
    /* CSS for syntax highlighting */
    html { -webkit-text-size-adjust: 100%; }
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { color: #008000; } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { color: #008000; font-weight: bold; } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
</head>
<body>
<header id="title-block-header">
<h1 class="title">The Rust Odyssey: A C++ Developer's Journey</h1>
<p class="author">Robin George Koshy</p>
<p class="date">January 2026</p>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#copyright" id="toc-copyright">Copyright</a>
<ul>
<li><a href="#disclaimer" id="toc-disclaimer">Disclaimer</a></li>
</ul></li>
<li><a href="#preface" id="toc-preface">Preface</a>
<ul>
<li><a href="#who-this-book-is-for" id="toc-who-this-book-is-for">Who
This Book Is For</a></li>
<li><a href="#who-this-book-is-not-for"
id="toc-who-this-book-is-not-for">Who This Book Is Not For</a></li>
<li><a href="#what-this-book-teaches"
id="toc-what-this-book-teaches">What This Book Teaches</a></li>
<li><a href="#what-to-expect" id="toc-what-to-expect">What to
Expect</a></li>
<li><a href="#a-note-on-tone" id="toc-a-note-on-tone">A Note on
Tone</a></li>
<li><a href="#acknowledgments"
id="toc-acknowledgments">Acknowledgments</a></li>
</ul></li>
<li><a href="#how-to-read-this-book" id="toc-how-to-read-this-book">How
to Read This Book</a>
<ul>
<li><a href="#chapter-progression" id="toc-chapter-progression">Chapter
Progression</a></li>
<li><a href="#the-role-of-appendices"
id="toc-the-role-of-appendices">The Role of Appendices</a></li>
<li><a href="#patience-with-early-friction"
id="toc-patience-with-early-friction">Patience with Early
Friction</a></li>
<li><a href="#do-not-translate-mechanically"
id="toc-do-not-translate-mechanically">Do Not Translate
Mechanically</a></li>
<li><a href="#code-examples" id="toc-code-examples">Code
Examples</a></li>
<li><a href="#how-to-use-this-book" id="toc-how-to-use-this-book">How to
Use This Book</a></li>
<li><a href="#what-this-book-wont-teach-you"
id="toc-what-this-book-wont-teach-you">What This Book Won’t Teach
You</a></li>
</ul></li>
<li><a href="#a-note-on-examples" id="toc-a-note-on-examples">A Note on
Examples</a>
<ul>
<li><a href="#why-examples-are-small"
id="toc-why-examples-are-small">Why Examples Are Small</a></li>
<li><a href="#examples-are-illustrative-not-production-ready"
id="toc-examples-are-illustrative-not-production-ready">Examples Are
Illustrative, Not Production-Ready</a></li>
<li><a href="#correctness-over-completeness"
id="toc-correctness-over-completeness">Correctness Over
Completeness</a></li>
<li><a href="#c-examples-are-minimal"
id="toc-c-examples-are-minimal">C++ Examples Are Minimal</a></li>
<li><a href="#what-to-do-with-examples"
id="toc-what-to-do-with-examples">What to Do with Examples</a></li>
</ul></li>
<li><a href="#why-rust-exists-through-a-c-lens"
id="toc-why-rust-exists-through-a-c-lens">1. Why Rust Exists (Through a
C++ Lens)</a>
<ul>
<li><a href="#why-this-matters-to-a-c-developer"
id="toc-why-this-matters-to-a-c-developer">Why This Matters to a C++
Developer</a></li>
<li><a href="#the-c-mental-model" id="toc-the-c-mental-model">The C++
Mental Model</a></li>
<li><a href="#where-the-model-breaks-down"
id="toc-where-the-model-breaks-down">Where the Model Breaks
Down</a></li>
<li><a href="#rusts-model" id="toc-rusts-model">Rust’s Model</a></li>
<li><a href="#takeaways-for-c-developers"
id="toc-takeaways-for-c-developers">Takeaways for C++
Developers</a></li>
</ul></li>
<li><a href="#hello-world-without-the-lies"
id="toc-hello-world-without-the-lies">2. Hello World Without the
Lies</a>
<ul>
<li><a href="#why-this-matters-to-a-c-developer-1"
id="toc-why-this-matters-to-a-c-developer-1">Why This Matters to a C++
Developer</a></li>
<li><a href="#the-c-mental-model-1" id="toc-the-c-mental-model-1">The
C++ Mental Model</a></li>
<li><a href="#where-the-model-breaks-down-1"
id="toc-where-the-model-breaks-down-1">Where the Model Breaks
Down</a></li>
<li><a href="#rusts-model-1" id="toc-rusts-model-1">Rust’s
Model</a></li>
<li><a href="#takeaways-for-c-developers-1"
id="toc-takeaways-for-c-developers-1">Takeaways for C++
Developers</a></li>
</ul></li>
<li><a href="#ownership-the-missing-concept-in-c"
id="toc-ownership-the-missing-concept-in-c">3. Ownership: The Missing
Concept in C++</a>
<ul>
<li><a href="#why-this-matters-to-a-c-developer-2"
id="toc-why-this-matters-to-a-c-developer-2">Why This Matters to a C++
Developer</a></li>
<li><a href="#the-c-mental-model-2" id="toc-the-c-mental-model-2">The
C++ Mental Model</a></li>
<li><a href="#where-the-model-breaks-down-2"
id="toc-where-the-model-breaks-down-2">Where the Model Breaks
Down</a></li>
<li><a href="#rusts-model-2" id="toc-rusts-model-2">Rust’s
Model</a></li>
<li><a href="#takeaways-for-c-developers-2"
id="toc-takeaways-for-c-developers-2">Takeaways for C++
Developers</a></li>
</ul></li>
<li><a href="#borrowing-vs-aliasing" id="toc-borrowing-vs-aliasing">4.
Borrowing vs Aliasing</a>
<ul>
<li><a href="#why-this-matters-to-a-c-developer-3"
id="toc-why-this-matters-to-a-c-developer-3">Why This Matters to a C++
Developer</a></li>
<li><a href="#the-c-mental-model-3" id="toc-the-c-mental-model-3">The
C++ Mental Model</a></li>
<li><a href="#where-the-model-breaks-down-3"
id="toc-where-the-model-breaks-down-3">Where the Model Breaks
Down</a></li>
<li><a href="#rusts-model-3" id="toc-rusts-model-3">Rust’s
Model</a></li>
<li><a href="#takeaways-for-c-developers-3"
id="toc-takeaways-for-c-developers-3">Takeaways for C++
Developers</a></li>
</ul></li>
<li><a href="#lifetimes-without-the-fear"
id="toc-lifetimes-without-the-fear">5. Lifetimes Without the Fear</a>
<ul>
<li><a href="#why-this-matters-to-a-c-developer-4"
id="toc-why-this-matters-to-a-c-developer-4">Why This Matters to a C++
Developer</a></li>
<li><a href="#the-c-mental-model-4" id="toc-the-c-mental-model-4">The
C++ Mental Model</a></li>
<li><a href="#where-the-model-breaks-down-4"
id="toc-where-the-model-breaks-down-4">Where the Model Breaks
Down</a></li>
<li><a href="#rusts-model-4" id="toc-rusts-model-4">Rust’s
Model</a></li>
<li><a href="#takeaways-for-c-developers-4"
id="toc-takeaways-for-c-developers-4">Takeaways for C++
Developers</a></li>
</ul></li>
<li><a href="#raii-reimagined" id="toc-raii-reimagined">6. RAII
Reimagined</a>
<ul>
<li><a href="#why-this-matters-to-a-c-developer-5"
id="toc-why-this-matters-to-a-c-developer-5">Why This Matters to a C++
Developer</a></li>
<li><a href="#the-c-mental-model-5" id="toc-the-c-mental-model-5">The
C++ Mental Model</a></li>
<li><a href="#where-the-model-breaks-down-5"
id="toc-where-the-model-breaks-down-5">Where the Model Breaks
Down</a></li>
<li><a href="#rusts-model-5" id="toc-rusts-model-5">Rust’s
Model</a></li>
<li><a href="#takeaways-for-c-developers-5"
id="toc-takeaways-for-c-developers-5">Takeaways for C++
Developers</a></li>
</ul></li>
<li><a href="#error-handling-without-exceptions"
id="toc-error-handling-without-exceptions">7. Error Handling Without
Exceptions</a>
<ul>
<li><a href="#why-this-matters-to-a-c-developer-6"
id="toc-why-this-matters-to-a-c-developer-6">Why This Matters to a C++
Developer</a></li>
<li><a href="#the-c-mental-model-6" id="toc-the-c-mental-model-6">The
C++ Mental Model</a></li>
<li><a href="#where-the-model-breaks-down-6"
id="toc-where-the-model-breaks-down-6">Where the Model Breaks
Down</a></li>
<li><a href="#rusts-model-6" id="toc-rusts-model-6">Rust’s
Model</a></li>
<li><a href="#takeaways-for-c-developers-6"
id="toc-takeaways-for-c-developers-6">Takeaways for C++
Developers</a></li>
</ul></li>
<li><a href="#traits-vs-templates" id="toc-traits-vs-templates">8.
Traits vs Templates</a>
<ul>
<li><a href="#why-this-matters-to-a-c-developer-7"
id="toc-why-this-matters-to-a-c-developer-7">Why This Matters to a C++
Developer</a></li>
<li><a href="#the-c-mental-model-7" id="toc-the-c-mental-model-7">The
C++ Mental Model</a></li>
<li><a href="#where-the-model-breaks-down-7"
id="toc-where-the-model-breaks-down-7">Where the Model Breaks
Down</a></li>
<li><a href="#rusts-model-7" id="toc-rusts-model-7">Rust’s
Model</a></li>
<li><a href="#takeaways-for-c-developers-7"
id="toc-takeaways-for-c-developers-7">Takeaways for C++
Developers</a></li>
</ul></li>
<li><a href="#zero-cost-abstractions-for-real"
id="toc-zero-cost-abstractions-for-real">9. Zero-Cost Abstractions (For
Real)</a>
<ul>
<li><a href="#why-this-matters-to-a-c-developer-8"
id="toc-why-this-matters-to-a-c-developer-8">Why This Matters to a C++
Developer</a></li>
<li><a href="#the-c-mental-model-8" id="toc-the-c-mental-model-8">The
C++ Mental Model</a></li>
<li><a href="#where-the-model-breaks-down-8"
id="toc-where-the-model-breaks-down-8">Where the Model Breaks
Down</a></li>
<li><a href="#rusts-model-8" id="toc-rusts-model-8">Rust’s
Model</a></li>
<li><a href="#takeaways-for-c-developers-8"
id="toc-takeaways-for-c-developers-8">Takeaways for C++
Developers</a></li>
</ul></li>
<li><a href="#unsafe-rust-for-c-veterans"
id="toc-unsafe-rust-for-c-veterans">10. Unsafe Rust for C++ Veterans</a>
<ul>
<li><a href="#why-this-matters-to-a-c-developer-9"
id="toc-why-this-matters-to-a-c-developer-9">Why This Matters to a C++
Developer</a></li>
<li><a href="#the-c-mental-model-9" id="toc-the-c-mental-model-9">The
C++ Mental Model</a></li>
<li><a href="#where-the-model-breaks-down-9"
id="toc-where-the-model-breaks-down-9">Where the Model Breaks
Down</a></li>
<li><a href="#rusts-model-9" id="toc-rusts-model-9">Rust’s
Model</a></li>
<li><a href="#takeaways-for-c-developers-9"
id="toc-takeaways-for-c-developers-9">Takeaways for C++
Developers</a></li>
</ul></li>
<li><a href="#concurrency-without-data-races"
id="toc-concurrency-without-data-races">11. Concurrency Without Data
Races</a>
<ul>
<li><a href="#why-this-matters-to-a-c-developer-10"
id="toc-why-this-matters-to-a-c-developer-10">Why This Matters to a C++
Developer</a></li>
<li><a href="#the-c-mental-model-10" id="toc-the-c-mental-model-10">The
C++ Mental Model</a></li>
<li><a href="#where-the-model-breaks-down-10"
id="toc-where-the-model-breaks-down-10">Where the Model Breaks
Down</a></li>
<li><a href="#rusts-model-10" id="toc-rusts-model-10">Rust’s
Model</a></li>
<li><a href="#takeaways-for-c-developers-10"
id="toc-takeaways-for-c-developers-10">Takeaways for C++
Developers</a></li>
</ul></li>
<li><a href="#when-rust-feels-hardand-why"
id="toc-when-rust-feels-hardand-why">12. When Rust Feels Hard—and
Why</a>
<ul>
<li><a href="#why-this-matters-to-a-c-developer-11"
id="toc-why-this-matters-to-a-c-developer-11">Why This Matters to a C++
Developer</a></li>
<li><a href="#the-c-mental-model-11" id="toc-the-c-mental-model-11">The
C++ Mental Model</a></li>
<li><a href="#where-the-model-breaks-down-11"
id="toc-where-the-model-breaks-down-11">Where the Model Breaks
Down</a></li>
<li><a href="#rusts-model-11" id="toc-rusts-model-11">Rust’s
Model</a></li>
<li><a href="#takeaways-for-c-developers-11"
id="toc-takeaways-for-c-developers-11">Takeaways for C++
Developers</a></li>
</ul></li>
<li><a href="#appendix-a.-common-c-pitfalls-and-their-rust-counterparts"
id="toc-appendix-a.-common-c-pitfalls-and-their-rust-counterparts">Appendix
A. Common C++ Pitfalls and Their Rust Counterparts</a>
<ul>
<li><a href="#why-this-matters-to-a-c-developer-12"
id="toc-why-this-matters-to-a-c-developer-12">Why This Matters to a C++
Developer</a></li>
<li><a href="#the-c-mental-model-12" id="toc-the-c-mental-model-12">The
C++ Mental Model</a></li>
<li><a href="#where-the-model-breaks-down-12"
id="toc-where-the-model-breaks-down-12">Where the Model Breaks
Down</a></li>
<li><a href="#rusts-model-12" id="toc-rusts-model-12">Rust’s
Model</a></li>
<li><a href="#takeaways-for-c-developers-12"
id="toc-takeaways-for-c-developers-12">Takeaways for C++
Developers</a></li>
</ul></li>
<li><a href="#appendix-b.-reading-rust-compiler-errors-like-a-human"
id="toc-appendix-b.-reading-rust-compiler-errors-like-a-human">Appendix
B. Reading Rust Compiler Errors Like a Human</a>
<ul>
<li><a href="#why-this-matters-to-a-c-developer-13"
id="toc-why-this-matters-to-a-c-developer-13">Why This Matters to a C++
Developer</a></li>
<li><a href="#the-c-mental-model-13" id="toc-the-c-mental-model-13">The
C++ Mental Model</a></li>
<li><a href="#where-the-model-breaks-down-13"
id="toc-where-the-model-breaks-down-13">Where the Model Breaks
Down</a></li>
<li><a href="#rusts-model-13" id="toc-rusts-model-13">Rust’s
Model</a></li>
<li><a href="#takeaways-for-c-developers-13"
id="toc-takeaways-for-c-developers-13">Takeaways for C++
Developers</a></li>
</ul></li>
<li><a href="#appendix-c.-mental-model-cheat-sheet-c-rust"
id="toc-appendix-c.-mental-model-cheat-sheet-c-rust">Appendix C. Mental
Model Cheat Sheet (C++ → Rust)</a>
<ul>
<li><a href="#why-this-matters-to-a-c-developer-14"
id="toc-why-this-matters-to-a-c-developer-14">Why This Matters to a C++
Developer</a></li>
<li><a href="#the-c-mental-model-14" id="toc-the-c-mental-model-14">The
C++ Mental Model</a></li>
<li><a href="#where-the-model-breaks-down-14"
id="toc-where-the-model-breaks-down-14">Where the Model Breaks
Down</a></li>
<li><a href="#rusts-model-14" id="toc-rusts-model-14">Rust’s
Model</a></li>
<li><a href="#takeaways-for-c-developers-14"
id="toc-takeaways-for-c-developers-14">Takeaways for C++
Developers</a></li>
</ul></li>
<li><a href="#acknowledgments-1"
id="toc-acknowledgments-1">Acknowledgments</a>
<ul>
<li><a href="#about-the-author" id="toc-about-the-author">About the
Author</a></li>
</ul></li>
<li><a href="#further-reading" id="toc-further-reading">Further
Reading</a>
<ul>
<li><a href="#official-rust-resources"
id="toc-official-rust-resources">Official Rust Resources</a></li>
<li><a href="#specialized-topics"
id="toc-specialized-topics">Specialized Topics</a></li>
<li><a href="#c-to-rust-transition" id="toc-c-to-rust-transition">C++ to
Rust Transition</a></li>
<li><a href="#what-not-to-read" id="toc-what-not-to-read">What Not to
Read</a></li>
<li><a href="#next-steps" id="toc-next-steps">Next Steps</a></li>
</ul></li>
</ul>
</nav>
<h1 id="copyright">Copyright</h1>
<p>Copyright © 2026 Robin George Koshy</p>
<p>All rights reserved.</p>
<p>No part of this publication may be reproduced, distributed, or
transmitted in any form or by any means, including photocopying,
recording, or other electronic or mechanical methods, without the prior
written permission of the author, except in the case of brief quotations
embodied in critical reviews and certain other noncommercial uses
permitted by copyright law.</p>
<hr />
<h2 id="disclaimer">Disclaimer</h2>
<p>The code examples in this book are provided for educational purposes
only. They are intended to illustrate concepts and are not warranted for
production use. The author makes no representations or warranties of any
kind concerning the accuracy, completeness, or suitability of the code
examples.</p>
<p>Use of the code examples is at your own risk. The author shall not be
liable for any damages arising from the use of this material.</p>
<hr />
<p>Rust is a trademark of the Mozilla Foundation.</p>
<p>C++ is a registered trademark of the International Organization for
Standardization.</p>
<p>All trademarks and registered trademarks are the property of their
respective owners.</p>
<h1 id="preface">Preface</h1>
<p>This book exists because learning Rust as an experienced C++
developer is harder than it should be.</p>
<p>Not because Rust is poorly designed, but because most Rust learning
materials assume you’re either new to systems programming or coming from
a garbage-collected language. If you’ve spent years with C++—managing
lifetimes manually, reasoning about move semantics, debugging memory
corruption—you already understand the problems Rust solves. What you
need is a translation layer between the mental models you’ve built and
the ones Rust enforces.</p>
<p>That’s what this book provides.</p>
<hr />
<h2 id="who-this-book-is-for">Who This Book Is For</h2>
<p>This book is written for experienced C++ developers.
Specifically:</p>
<ul>
<li>You have 5+ years of professional C++ experience</li>
<li>You’re comfortable with RAII, move semantics, and templates</li>
<li>You’ve debugged use-after-free, iterator invalidation, and data
races</li>
<li>You understand the trade-offs between performance and safety</li>
<li>You’re curious about Rust but skeptical of the hype</li>
</ul>
<p>If you’ve never written C++, this book will not make sense. If you’re
new to systems programming, start elsewhere.</p>
<hr />
<h2 id="who-this-book-is-not-for">Who This Book Is Not For</h2>
<p>This is not:</p>
<ul>
<li>An introduction to programming</li>
<li>A comprehensive Rust reference</li>
<li>A guide to building production systems in Rust</li>
<li>An argument that Rust is better than C++</li>
</ul>
<p>If you’re looking for a tutorial that walks you through syntax
step-by-step, read <em>The Rust Programming Language</em> (the official
book). If you want to understand why Rust makes the design choices it
does—and how those choices map to problems you’ve already solved in
C++—keep reading.</p>
<hr />
<h2 id="what-this-book-teaches">What This Book Teaches</h2>
<p>This book focuses on mental models, not syntax.</p>
<p>Each chapter takes a concept you already understand in C++ and shows:
- Where your C++ intuition transfers cleanly - Where it breaks down -
Why Rust enforces different constraints - What trade-offs Rust is
making</p>
<p>The goal is not to make you love Rust. The goal is to make you
understand it well enough to decide whether it’s the right tool for your
problem.</p>
<hr />
<h2 id="what-to-expect">What to Expect</h2>
<p>Rust will feel restrictive at first. The borrow checker will reject
code that would compile in C++. You’ll be tempted to fight it, to find
workarounds, to conclude that Rust is too rigid for real-world use.</p>
<p>That frustration is normal. It’s also temporary.</p>
<p>The borrow checker isn’t rejecting your code arbitrarily. It’s
enforcing invariants you’d maintain manually in C++—invariants that,
when violated, cause the bugs you’ve spent hours debugging. The
difference is that Rust makes those invariants explicit and checks them
at compile time.</p>
<p>This book won’t eliminate that friction, but it will explain why the
friction exists and what you gain from it.</p>
<hr />
<h2 id="a-note-on-tone">A Note on Tone</h2>
<p>This book is not evangelical. Rust is not a silver bullet. It makes
trade-offs, and those trade-offs won’t make sense for every project.</p>
<p>If you’re working on a codebase with millions of lines of C++, a team
that knows C++ deeply, and tooling that catches most memory bugs, Rust
might not be worth the migration cost. If you’re starting a new project
where memory safety bugs are expensive and hard to debug, Rust might be
exactly what you need.</p>
<p>The book presents the trade-offs. You make the call.</p>
<hr />
<h2 id="acknowledgments">Acknowledgments</h2>
<p>This book would not exist without the Rust community’s documentation,
the C++ community’s decades of hard-won knowledge, and the engineers
who’ve debugged enough memory corruption to appreciate what Rust
prevents.</p>
<h1 id="how-to-read-this-book">How to Read This Book</h1>
<p>This book is structured to build mental models incrementally. Each
chapter assumes you’ve internalized the previous ones.</p>
<hr />
<h2 id="chapter-progression">Chapter Progression</h2>
<p><strong>Chapters 1–3: Core Mental Models</strong><br />
These chapters establish the foundational concepts: ownership,
borrowing, and lifetimes. If you skip these, the rest of the book won’t
make sense. Even if you’ve read Rust documentation before, read these
chapters. They’re written specifically to map C++ intuition to Rust’s
model.</p>
<p><strong>Chapters 4–7: Practical Patterns</strong><br />
These chapters show how Rust’s core concepts apply to real-world
problems: RAII, error handling, and resource management. This is where
you’ll start to see why Rust’s constraints exist.</p>
<p><strong>Chapters 8–11: Advanced Topics</strong><br />
These chapters cover traits, zero-cost abstractions, unsafe Rust, and
concurrency. They assume you’re comfortable with the borrow checker and
are ready to see how Rust’s design enables performance without
sacrificing safety.</p>
<p><strong>Chapter 12: When Rust Feels Hard</strong><br />
This chapter addresses the frustration you’ll inevitably feel. It’s not
a pep talk—it’s a practical guide to recognizing when you’re fighting
the language and when the language is preventing a real bug.</p>
<hr />
<h2 id="the-role-of-appendices">The Role of Appendices</h2>
<p>The appendices are reference material, not required reading:</p>
<ul>
<li><strong>Appendix A</strong> catalogs common C++ pitfalls and shows
how Rust prevents them</li>
<li><strong>Appendix B</strong> teaches you how to read Rust compiler
errors (which are more helpful than you expect)</li>
<li><strong>Appendix C</strong> provides a mental model cheat sheet for
quick reference</li>
</ul>
<p>Use them when you’re stuck, not as a substitute for the main
chapters.</p>
<hr />
<h2 id="patience-with-early-friction">Patience with Early Friction</h2>
<p>The first three chapters will feel slow. You’ll be tempted to skim,
to jump ahead, to start writing code before you understand the
model.</p>
<p>Don’t.</p>
<p>Rust’s borrow checker is unforgiving if you don’t understand why it
exists. The time you spend building the right mental model in Chapters
1–3 will save you hours of frustration later.</p>
<p>If you find yourself fighting the compiler repeatedly, go back and
reread Chapter 3 (Ownership) and Chapter 5 (Lifetimes). The problem is
almost always a gap in your mental model, not a limitation of the
language.</p>
<hr />
<h2 id="do-not-translate-mechanically">Do Not Translate
Mechanically</h2>
<p>The biggest mistake C++ developers make when learning Rust is trying
to translate C++ patterns directly.</p>
<p>This doesn’t work.</p>
<p>Rust is not “C++ with a stricter compiler.” It’s a different set of
trade-offs, enforced at compile time. Patterns that make sense in
C++—like storing raw pointers in a container, or using inheritance for
polymorphism—don’t map cleanly to Rust.</p>
<p>Instead of asking “How do I do X in Rust?” ask “Why does Rust make X
difficult?” The answer will usually reveal a better approach.</p>
<hr />
<h2 id="code-examples">Code Examples</h2>
<p>The code examples in this book are small and focused. They’re
designed to illustrate a single concept, not to be production-ready.</p>
<p>If an example feels contrived, that’s intentional. Real-world code
has too many moving parts to isolate the concept being taught. Once you
understand the concept, you’ll recognize it in larger codebases.</p>
<p>All Rust code in this book compiles on stable Rust. If an example
doesn’t compile, that’s a bug—report it.</p>
<hr />
<h2 id="how-to-use-this-book">How to Use This Book</h2>
<p><strong>If you’re evaluating Rust for a project:</strong><br />
Read Chapters 1–3 and Chapter 12. That will give you enough context to
understand the trade-offs.</p>
<p><strong>If you’re committed to learning Rust:</strong><br />
Read the book front-to-back. Do not skip chapters. The mental models
build on each other.</p>
<p><strong>If you’re stuck on a specific problem:</strong><br />
Check the appendices first. If that doesn’t help, reread the chapter
that introduced the concept you’re struggling with.</p>
<hr />
<h2 id="what-this-book-wont-teach-you">What This Book Won’t Teach
You</h2>
<p>This book will not teach you: - How to set up a Rust development
environment - How to use Cargo (Rust’s build tool) - How to write
idiomatic Rust for every use case - How to integrate Rust with existing
C++ codebases</p>
<p>For those topics, consult the official Rust documentation and
ecosystem-specific guides.</p>
<p>This book teaches you how to think in Rust. The rest is syntax.</p>
<h1 id="a-note-on-examples">A Note on Examples</h1>
<p>The code examples in this book are deliberately small and
focused.</p>
<hr />
<h2 id="why-examples-are-small">Why Examples Are Small</h2>
<p>Real-world code is messy. It has error handling, edge cases,
performance optimizations, and dependencies on other modules. That
complexity obscures the concept being taught.</p>
<p>The examples in this book strip away everything except the core idea.
If you’re looking at a 10-line example and thinking “this would never
work in production,” you’re right. That’s not the point.</p>
<p>The point is to isolate the mental model. Once you understand why
Rust enforces a particular constraint in a simple example, you’ll
recognize that constraint in real code—and you’ll know how to work with
it instead of against it.</p>
<hr />
<h2 id="examples-are-illustrative-not-production-ready">Examples Are
Illustrative, Not Production-Ready</h2>
<p>None of the examples in this book are intended for production use.
They: - Omit error handling when it’s not relevant to the concept - Use
simplified types to reduce cognitive load - Ignore performance
considerations that would matter in real code - Assume a single-threaded
context unless concurrency is the topic</p>
<p>If you copy an example into your codebase, you’ll need to add: -
Proper error handling - Input validation - Performance optimizations -
Thread safety (if applicable)</p>
<p>The examples are teaching tools, not templates.</p>
<hr />
<h2 id="correctness-over-completeness">Correctness Over
Completeness</h2>
<p>Every Rust example in this book compiles on stable Rust. If an
example doesn’t compile, that’s a bug.</p>
<p>However, “compiles” does not mean “handles all edge cases” or “is the
best way to solve the problem.” It means the example demonstrates the
concept without introducing unrelated complexity.</p>
<p>When an example shows a pattern that’s suboptimal in production, the
text will note it. The goal is to teach you how Rust works, not to
prescribe how you should use it.</p>
<hr />
<h2 id="c-examples-are-minimal">C++ Examples Are Minimal</h2>
<p>C++ examples appear only when they clarify the contrast with Rust.
They are not: - Comprehensive demonstrations of C++ best practices -
Optimized for performance - Representative of modern C++ idioms in all
cases</p>
<p>They exist to show where C++ and Rust diverge, and why that
divergence matters.</p>
<p>If a C++ example looks like code you’d never write, consider whether
the Rust equivalent prevents you from writing it at all. That’s often
the point.</p>
<hr />
<h2 id="what-to-do-with-examples">What to Do with Examples</h2>
<p><strong>When reading:</strong><br />
Focus on the concept, not the specifics. Ask yourself: “What invariant
is Rust enforcing here? How would I maintain that invariant manually in
C++?”</p>
<p><strong>When experimenting:</strong><br />
Type the examples yourself. Modify them. Break them. See what the
compiler says. Rust’s error messages are part of the learning
process.</p>
<p><strong>When applying to your code:</strong><br />
Don’t copy examples directly. Use them to understand the constraint,
then design your solution around that constraint.</p>
<p>The examples are a map, not the territory.</p>
<h1 id="why-rust-exists-through-a-c-lens">1. Why Rust Exists (Through a
C++ Lens)</h1>
<blockquote>
<p>You’ve spent years mastering C++, learning when to use
<code>unique_ptr</code> vs raw pointers, when move semantics matter, and
how to avoid undefined behavior. Rust claims to solve problems you’ve
learned to work around—but at what cost?</p>
</blockquote>
<hr />
<h2 id="why-this-matters-to-a-c-developer">Why This Matters to a C++
Developer</h2>
<p>C++ gives you complete control. You manage memory, choose your
abstractions, and pay only for what you use. When things go wrong, you
debug, add assertions, run sanitizers, or tighten code review.</p>
<p>This works. Millions of lines of production C++ prove it.</p>
<p>But it requires: - Discipline across teams and years - Tooling that
catches problems after the fact - Conventions that aren’t enforced by
the language - Expertise that doesn’t scale with codebase size</p>
<p>The larger the team, the longer the project lives, the more fragile
this becomes. Not because C++ is broken, but because it trusts you
completely—even when you’re tired, distracted, or onboarding someone
new.</p>
<p>Rust doesn’t trust you. It makes that lack of trust explicit,
compile-time, and non-negotiable.</p>
<hr />
<h2 id="the-c-mental-model">The C++ Mental Model</h2>
<p>As a C++ developer, you think in terms of:</p>
<p><strong>Ownership by convention</strong><br />
You know who owns a pointer. It’s in the variable name
(<code>raw_ptr</code>, <code>owner_ptr</code>), the comment, or the team
wiki. The compiler doesn’t enforce it—you do.</p>
<p><strong>Safety through discipline</strong><br />
You avoid dangling pointers by being careful. You use RAII. You follow
the rule of three/five. You run Valgrind. You write tests.</p>
<p><strong>Performance through control</strong><br />
You choose when to copy, when to move, when to allocate. The language
doesn’t second-guess you. If you want a raw pointer into a vector’s
buffer, you get one—and you’re responsible for not invalidating it.</p>
<p><strong>Flexibility over guarantees</strong><br />
C++ lets you do anything. Cast away <code>const</code>, reinterpret
memory, ignore return values. The language assumes you know what you’re
doing. When you don’t, the bug is yours to find.</p>
<p>This mental model works when: - The team is small and experienced -
Code review catches mistakes - Tooling fills the gaps - The codebase
doesn’t outlive institutional knowledge</p>
<hr />
<h2 id="where-the-model-breaks-down">Where the Model Breaks Down</h2>
<p>The problem isn’t that C++ allows unsafe code. The problem is that
<strong>safe and unsafe code look identical</strong>.</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> vec <span class="op">=</span> <span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">};</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span><span class="op">*</span> ptr <span class="op">=</span> <span class="op">&amp;</span>vec<span class="op">[</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>vec<span class="op">.</span>push_back<span class="op">(</span><span class="dv">4</span><span class="op">);</span>  <span class="co">// ptr is now dangling</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="co">// No warning. No error. Just undefined behavior.</span></span></code></pre></div>
<p>The compiler can’t help you here. It doesn’t track: - Whether a
pointer is still valid - Whether two threads are accessing the same
memory - Whether you’ve moved from an object and then used it again</p>
<p>You catch these bugs through: - Code review (if the reviewer notices)
- Sanitizers (if you run them, and they trigger) - Production crashes
(if you’re unlucky)</p>
<p>At scale, this doesn’t work: - A refactor in one module breaks
assumptions in another - A threading bug appears only under load - A
use-after-free hides in a rarely-executed path</p>
<p>The cost isn’t the bug itself—it’s the <strong>time to find
it</strong>, the <strong>confidence lost</strong>, and the
<strong>features not shipped</strong> because you’re debugging memory
corruption.</p>
<p>C++ gives you the tools to write safe code. It doesn’t stop you from
writing unsafe code. Rust inverts that: it stops you from writing unsafe
code unless you explicitly opt out.</p>
<p>That’s not a value judgment. It’s a trade-off. The question is
whether that trade-off makes sense for your project.</p>
<hr />
<h2 id="rusts-model">Rust’s Model</h2>
<p>Rust makes safety the default, not the exception. The compiler
enforces what C++ leaves to discipline.</p>
<p><strong>Ownership is explicit and checked.</strong><br />
Every value has exactly one owner. When the owner goes out of scope, the
value is dropped. The compiler tracks this and prevents use-after-free
at compile time.</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> process_data() <span class="op">{</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> data <span class="op">=</span> <span class="pp">vec!</span>[<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span>]<span class="op">;</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    consume(data)<span class="op">;</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">// println!(&quot;{:?}&quot;, data);  // Compile error: value moved</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> consume(v<span class="op">:</span> <span class="dt">Vec</span><span class="op">&lt;</span><span class="dt">i32</span><span class="op">&gt;</span>) <span class="op">{</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Use v here</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>  <span class="co">// v is dropped here</span></span></code></pre></div>
<p>The compiler knows <code>data</code> was moved into
<code>consume</code>. Trying to use it afterward is a compile error, not
undefined behavior.</p>
<p><strong>Borrowing is tracked.</strong><br />
References have lifetimes. The compiler ensures a reference never
outlives the data it points to.</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> get_first(v<span class="op">:</span> <span class="op">&amp;</span><span class="dt">Vec</span><span class="op">&lt;</span><span class="dt">i32</span><span class="op">&gt;</span>) <span class="op">-&gt;</span> <span class="op">&amp;</span><span class="dt">i32</span> <span class="op">{</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    <span class="op">&amp;</span>v[<span class="dv">0</span>]  <span class="co">// Lifetime tied to v</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="co">// This won&#39;t compile:</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="co">// fn dangling() -&gt; &amp;i32 {</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="co">//     let v = vec![1, 2, 3];</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span class="co">//     &amp;v[0]  // Error: v doesn&#39;t live long enough</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a><span class="co">//            // (The reference would outlive v - see Chapter 5)</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a><span class="co">// }</span></span></code></pre></div>
<p>The compiler rejects code that would create dangling references. Not
at runtime—at compile time.</p>
<p><strong>Mutability and aliasing are exclusive.</strong><br />
You can have multiple immutable references, or one mutable reference,
but not both. This prevents iterator invalidation and data races.</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">mut</span> vec <span class="op">=</span> <span class="pp">vec!</span>[<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span>]<span class="op">;</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> first <span class="op">=</span> <span class="op">&amp;</span>vec[<span class="dv">0</span>]<span class="op">;</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="co">// vec.push(4);  // Compile error: can&#39;t mutate while borrowed</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> first)<span class="op">;</span></span></code></pre></div>
<p>The compiler enforces this. You can’t accidentally invalidate a
reference by modifying the container.</p>
<p><strong>The trade-off is upfront complexity.</strong><br />
You must satisfy the compiler before your code runs. This is slower when
prototyping, but eliminates entire classes of bugs. The cost is paid
once, at compile time, not repeatedly in production.</p>
<hr />
<h2 id="takeaways-for-c-developers">Takeaways for C++ Developers</h2>
<p><strong>Mental model shift:</strong> - Ownership is not a
convention—it’s enforced by the compiler - References have lifetimes
that the compiler tracks - Mutability and aliasing cannot coexist</p>
<p><strong>Rules of thumb:</strong> - If you’re passing ownership, use
move semantics (default in Rust) - If you’re borrowing, use references
(<code>&amp;T</code> or <code>&amp;mut T</code>) - If the compiler
rejects your code, it’s preventing a bug you’d find later in C++</p>
<p><strong>Pitfalls:</strong> - Fighting the compiler means you’re
trying to do something unsafe - The borrow checker isn’t wrong—it’s
enforcing invariants you’d maintain manually in C++ - Cloning to satisfy
the compiler isn’t always wrong—sometimes it’s the correct solution
(especially for small types or when simplicity matters more than
performance)</p>
<p>Rust doesn’t make you a better programmer. It makes the compiler
enforce what you already know you should do.</p>
<hr />
<h1 id="hello-world-without-the-lies">2. Hello World Without the
Lies</h1>
<blockquote>
<p>Most Rust tutorials start with “Hello, World!” and make it look easy.
They’re lying by omission—Rust’s complexity doesn’t show up until you
try to do something real.</p>
</blockquote>
<hr />
<h2 id="why-this-matters-to-a-c-developer-1">Why This Matters to a C++
Developer</h2>
<p>In C++, you can write useful code immediately. You understand
pointers, references, and RAII. You know when to use <code>const</code>,
when to move, when to copy. The learning curve is smooth: start simple,
add complexity as needed.</p>
<p>Rust doesn’t work that way.</p>
<p>You’ll hit the borrow checker on day one. Not because you’re doing
something exotic—because you’re doing something normal. Passing a
mutable reference while holding an immutable one. Storing a reference in
a struct. Returning a reference to local data.</p>
<p>In C++, these patterns either work or fail at runtime. In Rust, they
fail at compile time, with error messages that feel like the compiler is
arguing with you.</p>
<p>This isn’t a bug in Rust. It’s the entire point. But it means the
learning curve is inverted: you pay the cost upfront, before you’ve
written anything useful.</p>
<hr />
<h2 id="the-c-mental-model-1">The C++ Mental Model</h2>
<p>When you learn C++, you start with: - Variables and types - Functions
and control flow - Pointers and references (maybe) - Classes and RAII
(eventually)</p>
<p>You can write working code at each stage. The complexity is optional.
You reach for <code>std::unique_ptr</code> when you need it, not because
the language forces you to think about ownership from line one.</p>
<p><strong>Learning is incremental.</strong><br />
You add concepts as your needs grow. A beginner can write a working
program without understanding move semantics. An expert uses them
everywhere. Both compile.</p>
<p><strong>The compiler is permissive.</strong><br />
It warns you about potential issues, but it trusts your judgment. If you
want to return a pointer to a local variable, the compiler might warn
you—but it won’t stop you.</p>
<p><strong>Mistakes are deferred.</strong><br />
You write code, it compiles, and you find out later whether it was
correct. Segfaults, data races, and memory leaks happen at runtime, not
compile time.</p>
<p>This model works because: - You can prototype quickly - You learn by
doing - The language doesn’t block you while you’re figuring things
out</p>
<hr />
<h2 id="where-the-model-breaks-down-1">Where the Model Breaks Down</h2>
<p>Rust inverts this completely.</p>
<p><strong>You can’t defer ownership decisions.</strong><br />
In C++, you can write a function that takes a pointer and figure out
ownership later. In Rust, you must decide upfront: does this function
borrow, take ownership, or return a reference? The compiler won’t let
you proceed until you answer.</p>
<p><strong>The compiler feels adversarial at first.</strong><br />
It rejects code that would compile and run fine in C++. Not because it’s
wrong, but because it <em>might</em> be wrong. The compiler doesn’t
trust you to get it right at runtime—it demands proof at compile
time.</p>
<p><strong>Mistakes are immediate.</strong><br />
You don’t get to run the code and see what happens. You fight the
compiler until it’s satisfied, then the code works. This feels backwards
if you’re used to iterating quickly and fixing bugs later.</p>
<p>The frustration is real: - You know what you want to do - You know it
would work in C++ - The compiler says no, and the error message doesn’t
help</p>
<p>This isn’t Rust being difficult for no reason. It’s Rust enforcing
guarantees that C++ leaves to you. But it means your first week with
Rust will feel like fighting the language, not learning it.</p>
<p>The payoff comes later: once the code compiles, whole classes of bugs
are gone. But you have to survive the first week to get there.</p>
<hr />
<h2 id="rusts-model-1">Rust’s Model</h2>
<p>Rust forces you to think about ownership from the start. There’s no
“simple mode” where you can ignore it.</p>
<p><strong>Ownership decisions are mandatory.</strong><br />
Every function parameter declares whether it takes ownership, borrows
immutably, or borrows mutably. You can’t defer this decision.</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> process_owned(data<span class="op">:</span> <span class="dt">String</span>) <span class="op">{</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Takes ownership, data is dropped at end</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> process_borrowed(data<span class="op">:</span> <span class="op">&amp;</span><span class="dt">String</span>) <span class="op">{</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Borrows, doesn&#39;t take ownership</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> process_mut(data<span class="op">:</span> <span class="op">&amp;</span><span class="kw">mut</span> <span class="dt">String</span>) <span class="op">{</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Mutable borrow, can modify but doesn&#39;t own</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>    data<span class="op">.</span>push_str(<span class="st">&quot; modified&quot;</span>)<span class="op">;</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>In C++, you’d use <code>std::string</code>,
<code>const std::string&amp;</code>, or <code>std::string&amp;</code>.
The difference is that Rust enforces the semantics—you can’t use
<code>data</code> after passing it to <code>process_owned</code>.</p>
<p><strong>The compiler is strict, not helpful (at
first).</strong><br />
It rejects code that would work in C++, even if you know it’s safe.</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> read_file(path<span class="op">:</span> <span class="op">&amp;</span><span class="dt">str</span>) <span class="op">-&gt;</span> <span class="pp">std::io::</span><span class="dt">Result</span><span class="op">&lt;</span><span class="dt">String</span><span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">mut</span> file <span class="op">=</span> <span class="pp">std::fs::File::</span>open(path)<span class="op">?;</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">mut</span> contents <span class="op">=</span> <span class="dt">String</span><span class="pp">::</span>new()<span class="op">;</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// This won&#39;t compile:</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">// let first_char = contents.chars().next();  // Immutable borrow</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">// file.read_to_string(&amp;mut contents)?;       // Mutable borrow - Error!</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// println!(&quot;{:?}&quot;, first_char);</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>    file<span class="op">.</span>read_to_string(<span class="op">&amp;</span><span class="kw">mut</span> contents)<span class="op">?;</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>    <span class="cn">Ok</span>(contents)</span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The compiler prevents you from holding an immutable reference while
mutating. In C++, this would compile and might work—or might crash if
the string reallocates.</p>
<p><strong>Errors are explicit.</strong><br />
Functions that can fail return <code>Result&lt;T, E&gt;</code>. You must
handle the error or explicitly propagate it with <code>?</code>.</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> read_file(path<span class="op">:</span> <span class="op">&amp;</span><span class="dt">str</span>) <span class="op">-&gt;</span> <span class="pp">std::io::</span><span class="dt">Result</span><span class="op">&lt;</span><span class="dt">String</span><span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">mut</span> file <span class="op">=</span> <span class="pp">std::fs::File::</span>open(path)<span class="op">?;</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">mut</span> contents <span class="op">=</span> <span class="dt">String</span><span class="pp">::</span>new()<span class="op">;</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>    file<span class="op">.</span>read_to_string(<span class="op">&amp;</span><span class="kw">mut</span> contents)<span class="op">?;</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>    <span class="cn">Ok</span>(contents)</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>You can’t ignore the <code>Result</code>. The compiler forces you to
handle it or propagate it. No silent failures.</p>
<p><strong>The learning curve is front-loaded.</strong><br />
You fight the compiler for the first week. But once you understand what
it’s checking, the fights become rare. The code that compiles tends to
work.</p>
<hr />
<h2 id="takeaways-for-c-developers-1">Takeaways for C++ Developers</h2>
<p><strong>Mental model shift:</strong> - You can’t prototype by
ignoring ownership—the compiler won’t let you - Errors are values, not
exceptions—you handle them explicitly - The compiler is checking
invariants you’d maintain manually in C++</p>
<p><strong>Rules of thumb:</strong> - Start with borrowing
(<code>&amp;T</code>) unless you need ownership - Use
<code>&amp;mut T</code> only when you need to modify - Use
<code>?</code> to propagate errors up the call stack - If the compiler
says no, restructure your code—don’t fight it</p>
<p><strong>Pitfalls:</strong> - Don’t try to write C++ in Rust—the
patterns don’t translate directly - The first week will be
frustrating—this is normal - Cloning to make the compiler happy is
sometimes the right answer</p>
<p>The payoff comes later: once your code compiles, it usually works.
The bugs you’d spend days debugging in C++ are caught at compile
time.</p>
<hr />
<h1 id="ownership-the-missing-concept-in-c">3. Ownership: The Missing
Concept in C++</h1>
<blockquote>
<p>In C++, you know who owns a resource—it’s in the variable name, the
comment, or the convention. Rust makes ownership a first-class language
feature, and suddenly every pointer decision becomes explicit.</p>
</blockquote>
<hr />
<h2 id="why-this-matters-to-a-c-developer-2">Why This Matters to a C++
Developer</h2>
<p>You already think about ownership. Every time you choose between
<code>unique_ptr</code>, <code>shared_ptr</code>, or a raw pointer,
you’re making an ownership decision.</p>
<ul>
<li><code>unique_ptr&lt;T&gt;</code>: I own this, and I’m the only
owner</li>
<li><code>shared_ptr&lt;T&gt;</code>: Ownership is shared,
reference-counted</li>
<li><code>T*</code>: I don’t own this, someone else does (probably)</li>
</ul>
<p>This works through discipline: - Naming conventions
(<code>owner_</code>, <code>borrowed_</code>) - Code review (“Who
deletes this?”) - Documentation (“Caller retains ownership”) - Smart
pointers that encode intent</p>
<p>The compiler doesn’t enforce any of this. It trusts you to get it
right. When you don’t, you get: - Double frees - Use-after-free - Memory
leaks - Dangling pointers</p>
<p>These bugs are rare in well-written C++, but they’re catastrophic
when they happen. And they’re invisible to the compiler.</p>
<hr />
<h2 id="the-c-mental-model-2">The C++ Mental Model</h2>
<p>In C++, ownership is a <strong>convention</strong>, not a rule.</p>
<p><strong>Ownership is implicit.</strong><br />
You pass a pointer to a function. Does the function take ownership?
Maybe. It depends on the documentation, the function name, or the team’s
coding standards. The compiler doesn’t know and doesn’t care.</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> process<span class="op">(</span>Widget<span class="op">*</span> w<span class="op">);</span>  <span class="co">// Who owns w? Unclear.</span></span></code></pre></div>
<p><strong>Transfer is manual.</strong><br />
When you want to transfer ownership, you use <code>std::move</code> or
pass a <code>unique_ptr</code>. But nothing stops you from using the
object after the move—it’s just undefined behavior.</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> ptr <span class="op">=</span> <span class="bu">std::</span>make_unique<span class="op">&lt;</span>Widget<span class="op">&gt;();</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>consume<span class="op">(</span><span class="bu">std::</span>move<span class="op">(</span>ptr<span class="op">));</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>ptr<span class="op">-&gt;</span>do_something<span class="op">();</span>  <span class="co">// Compiles. Undefined behavior.</span></span></code></pre></div>
<p><strong>Shared ownership is opt-in.</strong><br />
If you need multiple owners, you use <code>shared_ptr</code>. It’s
explicit, reference-counted, and has runtime overhead. Most of the time,
you avoid it.</p>
<p><strong>Borrowing is invisible.</strong><br />
When you pass a reference or a raw pointer, you’re borrowing—but the
compiler doesn’t track it. If the owner destroys the object while you’re
still using it, that’s your problem.</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>Widget<span class="op">*</span> get_widget<span class="op">()</span> <span class="op">{</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>    Widget w<span class="op">;</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">&amp;</span>w<span class="op">;</span>  <span class="co">// Dangling pointer. Modern compilers warn or error on this.</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>This model works because: - Experienced developers internalize the
rules - Code review catches mistakes - Smart pointers make ownership
explicit (when you use them)</p>
<hr />
<h2 id="where-the-model-breaks-down-2">Where the Model Breaks Down</h2>
<p>The problem is that <strong>ownership violations look like normal
code</strong>.</p>
<p><strong>The compiler can’t help.</strong><br />
It doesn’t know which pointers are owners and which are borrowers. It
can’t tell you when a borrow outlives the owner. It can’t prevent you
from using a moved-from object.</p>
<p><strong>Conventions don’t scale.</strong><br />
In a small codebase, everyone knows the rules. In a large codebase, with
multiple teams and years of history, conventions drift. Someone passes a
raw pointer where a <code>unique_ptr</code> was expected. Someone stores
a reference that outlives the object.</p>
<p><strong>Refactoring is fragile.</strong><br />
You change a function to take ownership instead of borrowing. Every
caller still compiles—but now some of them have dangling pointers. The
compiler doesn’t notice. Your tests might not catch it. Production
does.</p>
<p><strong>The cost is deferred.</strong><br />
You write the code, it compiles, and you find out later whether the
ownership was correct. By then, the bug is in production, and you’re
debugging a crash that only happens under load.</p>
<p>Rust doesn’t let you defer this. Ownership is explicit, checked at
compile time, and non-negotiable. Every value has exactly one owner.
When the owner goes out of scope, the value is destroyed. If you want to
borrow, the compiler tracks the lifetime and ensures the borrow doesn’t
outlive the owner.</p>
<p>This feels restrictive at first—because it is. But it eliminates an
entire class of bugs that C++ leaves to you.</p>
<hr />
<h2 id="rusts-model-2">Rust’s Model</h2>
<p>Rust makes ownership a first-class language feature. Every value has
exactly one owner, and the compiler enforces this.</p>
<p><strong>Ownership is explicit in the type system.</strong><br />
When you pass a value to a function, you’re either transferring
ownership or borrowing. The compiler tracks this.</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> process(data<span class="op">:</span> <span class="dt">Vec</span><span class="op">&lt;</span><span class="dt">i32</span><span class="op">&gt;</span>) <span class="op">{</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Takes ownership of data</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;Processing {} items&quot;</span><span class="op">,</span> data<span class="op">.</span>len())<span class="op">;</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>  <span class="co">// data is dropped here</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> vec <span class="op">=</span> <span class="pp">vec!</span>[<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span>]<span class="op">;</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>    process(vec)<span class="op">;</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// println!(&quot;{:?}&quot;, vec);  // Compile error: value moved</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Compare to C++:</p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> process<span class="op">(</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> data<span class="op">);</span>  <span class="co">// Copy? Move? Unclear.</span></span></code></pre></div>
<p>In Rust, the signature tells you: <code>process</code> takes
ownership. After the call, <code>vec</code> is gone.</p>
<p><strong>Transfer is automatic and checked.</strong><br />
Move semantics are the default. The compiler prevents
use-after-move.</p>
<div class="sourceCode" id="cb13"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> s1 <span class="op">=</span> <span class="dt">String</span><span class="pp">::</span>from(<span class="st">&quot;hello&quot;</span>)<span class="op">;</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> s2 <span class="op">=</span> s1<span class="op">;</span>  <span class="co">// s1 moved to s2</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="co">// println!(&quot;{}&quot;, s1);  // Compile error: value moved</span></span></code></pre></div>
<p>In C++, you’d use <code>std::move(s1)</code>, but nothing stops you
from using <code>s1</code> afterward. In Rust, the compiler prevents
it.</p>
<p><strong>Borrowing is explicit and tracked.</strong><br />
When you don’t want to transfer ownership, you borrow with
<code>&amp;</code> or <code>&amp;mut</code>.</p>
<div class="sourceCode" id="cb14"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> read_data(data<span class="op">:</span> <span class="op">&amp;</span><span class="dt">Vec</span><span class="op">&lt;</span><span class="dt">i32</span><span class="op">&gt;</span>) <span class="op">{</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Borrows data, doesn&#39;t take ownership</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;First item: {}&quot;</span><span class="op">,</span> data[<span class="dv">0</span>])<span class="op">;</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>  <span class="co">// Borrow ends here</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> vec <span class="op">=</span> <span class="pp">vec!</span>[<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span>]<span class="op">;</span></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>    read_data(<span class="op">&amp;</span>vec)<span class="op">;</span></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;{:?}&quot;</span><span class="op">,</span> vec)<span class="op">;</span>  <span class="co">// Still valid</span></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The compiler ensures the borrow doesn’t outlive the owner. You can’t
return a reference to local data:</p>
<div class="sourceCode" id="cb15"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="co">// This won&#39;t compile:</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="co">// fn get_data() -&gt; &amp;Vec&lt;i32&gt; {</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a><span class="co">//     let vec = vec![1, 2, 3];</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a><span class="co">//     &amp;vec  // Error: vec doesn&#39;t live long enough</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a><span class="co">// }</span></span></code></pre></div>
<p><strong>Shared ownership is explicit and opt-in.</strong><br />
If you need multiple owners, you use <code>Rc&lt;T&gt;</code>
(reference-counted) or <code>Arc&lt;T&gt;</code> (atomic
reference-counted). The cost is visible in the type.</p>
<div class="sourceCode" id="cb16"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">std::rc::</span>Rc<span class="op">;</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> data <span class="op">=</span> <span class="pp">Rc::</span>new(<span class="pp">vec!</span>[<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span>])<span class="op">;</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> data2 <span class="op">=</span> <span class="pp">Rc::</span>clone(<span class="op">&amp;</span>data)<span class="op">;</span>  <span class="co">// Increment reference count</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>                                    <span class="co">// (Preferred over data.clone() for clarity)</span></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;{:?}&quot;</span><span class="op">,</span> data)<span class="op">;</span></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;{:?}&quot;</span><span class="op">,</span> data2)<span class="op">;</span></span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>  <span class="co">// Both dropped, reference count reaches 0, data freed</span></span></code></pre></div>
<p>Unlike C++ <code>shared_ptr</code>, you can’t accidentally create
shared ownership. You have to explicitly use <code>Rc</code> or
<code>Arc</code>.</p>
<hr />
<h2 id="takeaways-for-c-developers-2">Takeaways for C++ Developers</h2>
<p><strong>Mental model shift:</strong> - Ownership is not a
convention—it’s part of the type system - Move is the default, not
opt-in like <code>std::move</code> - Borrowing is explicit
(<code>&amp;T</code>), and the compiler tracks lifetimes - Shared
ownership requires explicit types (<code>Rc</code>,
<code>Arc</code>)</p>
<p><strong>Rules of thumb:</strong> - Pass by value (<code>T</code>)
when transferring ownership - Pass by reference (<code>&amp;T</code>)
when borrowing - Use <code>&amp;mut T</code> when you need to modify
without taking ownership - Use <code>Rc</code>/<code>Arc</code> only
when you truly need shared ownership</p>
<p><strong>Pitfalls:</strong> - Don’t fight the ownership
system—restructure your code instead - Cloning
(<code>data.clone()</code>) is sometimes the right answer, not a code
smell - <code>Rc</code> is not thread-safe—use <code>Arc</code> for
concurrent access - The compiler’s error messages about “moved value”
mean you tried to use something after transferring ownership</p>
<p>Rust’s ownership system is what C++ smart pointers try to be, but
enforced by the compiler instead of discipline.</p>
<hr />
<h1 id="borrowing-vs-aliasing">4. Borrowing vs Aliasing</h1>
<blockquote>
<p>In C++, you pass references freely—const or mutable, it doesn’t
matter. Rust treats aliasing and mutability as mutually exclusive, and
suddenly your intuition about references stops working.</p>
</blockquote>
<hr />
<h2 id="why-this-matters-to-a-c-developer-3">Why This Matters to a C++
Developer</h2>
<p>You use references constantly. They’re cheap, they avoid copies, and
they’re safer than pointers (usually). You pass
<code>const T&amp;</code> when you don’t need to modify, and
<code>T&amp;</code> when you do.</p>
<p>The rules are simple: - <code>const T&amp;</code>: Read-only access -
<code>T&amp;</code>: Read-write access - Multiple
<code>const T&amp;</code> references? Fine. - Multiple
<code>T&amp;</code> references? Also fine, just be careful.</p>
<p>“Be careful” means: - Don’t invalidate references by reallocating -
Don’t create data races in multithreaded code - Don’t modify through one
reference while reading through another</p>
<p>These are conventions. The compiler doesn’t enforce them. When you
violate them, you get undefined behavior—sometimes immediately,
sometimes much later.</p>
<p>In practice, this works. You learn the patterns, you avoid the
pitfalls, and you move on. Until you don’t, and you spend a day
debugging why a reference suddenly points to garbage.</p>
<hr />
<h2 id="the-c-mental-model-3">The C++ Mental Model</h2>
<p>In C++, references are <strong>aliases</strong>. They’re just another
name for the same object.</p>
<p><strong>Aliasing is unrestricted.</strong><br />
You can have as many references to the same object as you want. Const or
mutable, it doesn’t matter—the compiler lets you create them.</p>
<div class="sourceCode" id="cb17"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> vec <span class="op">=</span> <span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">};</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> a <span class="op">=</span> vec<span class="op">[</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> b <span class="op">=</span> vec<span class="op">[</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span><span class="op">&amp;</span> c <span class="op">=</span> vec<span class="op">[</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a><span class="co">// All valid. But modifying through c while a or b exist</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a><span class="co">// can lead to surprising behavior if the vector reallocates.</span></span></code></pre></div>
<p><strong>Mutability is a property of the reference.</strong><br />
A <code>const T&amp;</code> means <em>you</em> can’t modify it through
<em>this</em> reference. It doesn’t mean the object is immutable—someone
else might have a mutable reference to the same object.</p>
<div class="sourceCode" id="cb18"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> readonly <span class="op">=</span> vec<span class="op">[</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>vec<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="dv">42</span><span class="op">;</span>  <span class="co">// Modifies the object readonly refers to. Legal.</span></span></code></pre></div>
<p><strong>Invalidation is your problem.</strong><br />
If you hold a reference and the container reallocates, the reference
becomes dangling. The compiler doesn’t track this. You just have to
know.</p>
<div class="sourceCode" id="cb19"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> vec <span class="op">=</span> <span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">};</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span><span class="op">&amp;</span> ref <span class="op">=</span> vec<span class="op">[</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>vec<span class="op">.</span>push_back<span class="op">(</span><span class="dv">4</span><span class="op">);</span>  <span class="co">// May reallocate, invalidating ref</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a><span class="co">// ref is now dangling. No warning.</span></span></code></pre></div>
<p><strong>Concurrency is manual.</strong><br />
If two threads access the same object, and at least one is writing, you
have a data race. The compiler doesn’t prevent this. You use mutexes,
atomics, or thread-local storage.</p>
<p>This model is flexible: - You can alias freely - You can mutate
through any non-const reference - You manage the consequences
yourself</p>
<hr />
<h2 id="where-the-model-breaks-down-3">Where the Model Breaks Down</h2>
<p>The problem is that <strong>aliasing and mutation interact in subtle
ways</strong>.</p>
<p><strong>Iterator invalidation.</strong><br />
You hold a reference into a container. Someone modifies the container.
Your reference is now invalid. The compiler doesn’t know. Your code
compiles. You get undefined behavior.</p>
<div class="sourceCode" id="cb20"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> vec <span class="op">=</span> <span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">};</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span><span class="op">&amp;</span> first <span class="op">=</span> vec<span class="op">[</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>vec<span class="op">.</span>clear<span class="op">();</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>first <span class="op">=</span> <span class="dv">10</span><span class="op">;</span>  <span class="co">// Undefined behavior. Compiles fine.</span></span></code></pre></div>
<p><strong>Unintended mutation.</strong><br />
You pass a <code>const T&amp;</code> to a function, assuming the object
won’t change. But someone else has a mutable reference to the same
object. The function reads inconsistent state.</p>
<div class="sourceCode" id="cb21"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> process<span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> vec<span class="op">)</span> <span class="op">{</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> first <span class="op">=</span> vec<span class="op">[</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Someone else modifies vec here (via another reference)</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> second <span class="op">=</span> vec<span class="op">[</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// first != second, even though vec is &quot;const&quot;</span></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><strong>Data races.</strong><br />
Two threads access the same object. One reads, one writes. No
synchronization. Undefined behavior. The compiler doesn’t stop you.</p>
<p>The cost of this flexibility is vigilance: - You must track which
references are live - You must know when containers might reallocate -
You must synchronize access in multithreaded code</p>
<p>Rust makes a different trade-off: it restricts aliasing to prevent
these bugs. You can have multiple immutable references, or one mutable
reference, but not both. The compiler enforces this at compile time.</p>
<p>This feels limiting—because it is. But it eliminates iterator
invalidation, unintended mutation, and data races. Not through
discipline, but through the type system.</p>
<hr />
<h2 id="rusts-model-3">Rust’s Model</h2>
<p>Rust enforces a simple rule: you can have multiple immutable
references, or one mutable reference, but not both at the same time.</p>
<p><strong>Aliasing XOR mutability.</strong><br />
This is the core of Rust’s safety guarantee. You can alias (multiple
references), or you can mutate, but not both.</p>
<div class="sourceCode" id="cb22"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">mut</span> vec <span class="op">=</span> <span class="pp">vec!</span>[<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span>]<span class="op">;</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a><span class="co">// Multiple immutable borrows: OK</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> r1 <span class="op">=</span> <span class="op">&amp;</span>vec<span class="op">;</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> r2 <span class="op">=</span> <span class="op">&amp;</span>vec<span class="op">;</span></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a><span class="pp">println!</span>(<span class="st">&quot;{:?} {:?}&quot;</span><span class="op">,</span> r1<span class="op">,</span> r2)<span class="op">;</span></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a><span class="co">// One mutable borrow: OK (after immutable borrows end)</span></span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> r3 <span class="op">=</span> <span class="op">&amp;</span><span class="kw">mut</span> vec<span class="op">;</span></span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a>r3<span class="op">.</span>push(<span class="dv">4</span>)<span class="op">;</span></span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true" tabindex="-1"></a><span class="co">// But not both:</span></span>
<span id="cb22-13"><a href="#cb22-13" aria-hidden="true" tabindex="-1"></a><span class="co">// let r4 = &amp;vec;</span></span>
<span id="cb22-14"><a href="#cb22-14" aria-hidden="true" tabindex="-1"></a><span class="co">// let r5 = &amp;mut vec;  // Compile error: can&#39;t borrow mutably while borrowed immutably</span></span></code></pre></div>
<p>This prevents iterator invalidation at compile time:</p>
<div class="sourceCode" id="cb23"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">mut</span> vec <span class="op">=</span> <span class="pp">vec!</span>[<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span>]<span class="op">;</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> first <span class="op">=</span> <span class="op">&amp;</span>vec[<span class="dv">0</span>]<span class="op">;</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a><span class="co">// vec.push(4);  // Compile error: can&#39;t mutate while borrowed</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a><span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> first)<span class="op">;</span></span></code></pre></div>
<p>In C++, this would compile and might crash. In Rust, it’s a compile
error.</p>
<p><strong>Borrows have lifetimes.</strong><br />
The compiler tracks how long a borrow is valid. A borrow cannot outlive
the data it references.</p>
<div class="sourceCode" id="cb24"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> process_data() <span class="op">{</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> vec <span class="op">=</span> <span class="pp">vec!</span>[<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span>]<span class="op">;</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> first <span class="op">=</span> <span class="op">&amp;</span>vec[<span class="dv">0</span>]<span class="op">;</span></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> first)<span class="op">;</span></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>  <span class="co">// vec and first both dropped here</span></span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a><span class="co">// This won&#39;t compile:</span></span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a><span class="co">// fn get_first() -&gt; &amp;i32 {</span></span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a><span class="co">//     let vec = vec![1, 2, 3];</span></span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true" tabindex="-1"></a><span class="co">//     &amp;vec[0]  // Error: vec doesn&#39;t live long enough</span></span>
<span id="cb24-11"><a href="#cb24-11" aria-hidden="true" tabindex="-1"></a><span class="co">// }</span></span></code></pre></div>
<p><strong>Interior mutability is explicit.</strong><br />
If you need to mutate through a shared reference, you use
<code>Cell&lt;T&gt;</code> or <code>RefCell&lt;T&gt;</code>. The cost is
visible in the type.</p>
<div class="sourceCode" id="cb25"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">std::cell::</span>RefCell<span class="op">;</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Cache <span class="op">{</span></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>    data<span class="op">:</span> RefCell<span class="op">&lt;</span><span class="dt">Vec</span><span class="op">&lt;</span><span class="dt">String</span><span class="op">&gt;&gt;,</span></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span> Cache <span class="op">{</span></span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> add(<span class="op">&amp;</span><span class="kw">self</span><span class="op">,</span> item<span class="op">:</span> <span class="dt">String</span>) <span class="op">{</span></span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Mutate through shared reference</span></span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true" tabindex="-1"></a>        <span class="kw">self</span><span class="op">.</span>data<span class="op">.</span>borrow_mut()<span class="op">.</span>push(item)<span class="op">;</span></span>
<span id="cb25-11"><a href="#cb25-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb25-12"><a href="#cb25-12" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb25-13"><a href="#cb25-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> get(<span class="op">&amp;</span><span class="kw">self</span><span class="op">,</span> index<span class="op">:</span> <span class="dt">usize</span>) <span class="op">-&gt;</span> <span class="dt">Option</span><span class="op">&lt;</span><span class="dt">String</span><span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb25-14"><a href="#cb25-14" aria-hidden="true" tabindex="-1"></a>        <span class="kw">self</span><span class="op">.</span>data<span class="op">.</span>borrow()<span class="op">.</span>get(index)<span class="op">.</span>cloned()</span>
<span id="cb25-15"><a href="#cb25-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb25-16"><a href="#cb25-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb25-17"><a href="#cb25-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-18"><a href="#cb25-18" aria-hidden="true" tabindex="-1"></a><span class="co">// Note: RefCell checks borrowing rules at runtime.</span></span>
<span id="cb25-19"><a href="#cb25-19" aria-hidden="true" tabindex="-1"></a><span class="co">// If you call add() while a borrow from get() is active,</span></span>
<span id="cb25-20"><a href="#cb25-20" aria-hidden="true" tabindex="-1"></a><span class="co">// the program will panic. This is a runtime check, not compile-time.</span></span></code></pre></div>
<p><code>RefCell</code> checks borrowing rules at runtime. If you
violate them (e.g., borrow mutably while already borrowed), the program
panics. This is explicit—you know where the runtime checks are.</p>
<p><strong>Slices prevent invalidation.</strong><br />
Instead of holding a reference into a container, you use slices that
borrow the data.</p>
<div class="sourceCode" id="cb26"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> process_slice(data<span class="op">:</span> <span class="op">&amp;</span>[<span class="dt">i32</span>]) <span class="op">{</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> item <span class="kw">in</span> data <span class="op">{</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> item)<span class="op">;</span></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> vec <span class="op">=</span> <span class="pp">vec!</span>[<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">5</span>]<span class="op">;</span></span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true" tabindex="-1"></a>    process_slice(<span class="op">&amp;</span>vec[<span class="dv">1</span><span class="op">..</span><span class="dv">4</span>])<span class="op">;</span>  <span class="co">// Borrow a slice</span></span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">// vec is still valid here</span></span>
<span id="cb26-11"><a href="#cb26-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The slice borrows from <code>vec</code>, so you can’t modify
<code>vec</code> while the slice exists. The compiler enforces this.</p>
<hr />
<h2 id="takeaways-for-c-developers-3">Takeaways for C++ Developers</h2>
<p><strong>Mental model shift:</strong> - Aliasing and mutability are
mutually exclusive—enforced by the compiler - References have
lifetimes—the compiler tracks them - Interior mutability requires
explicit types (<code>Cell</code>, <code>RefCell</code>) - Iterator
invalidation is impossible (outside <code>unsafe</code>)</p>
<p><strong>Rules of thumb:</strong> - Use <code>&amp;T</code> for
shared, read-only access - Use <code>&amp;mut T</code> for exclusive,
mutable access - You can’t hold a reference while modifying the
container - If you need shared mutability, use <code>RefCell</code>
(single-threaded) or <code>Mutex</code> (multi-threaded)</p>
<p><strong>Pitfalls:</strong> - You can’t store a reference and modify
the source—restructure your code - <code>RefCell</code> checks at
runtime—panics if you violate borrowing rules - Cloning to avoid borrow
checker fights is sometimes correct - The compiler’s “cannot borrow as
mutable” errors mean you’re trying to alias and mutate</p>
<p>Rust’s borrowing rules eliminate data races and iterator
invalidation. The cost is that you must structure your code to satisfy
the compiler.</p>
<hr />
<h1 id="lifetimes-without-the-fear">5. Lifetimes Without the Fear</h1>
<blockquote>
<p>In C++, you know a reference must outlive its use—but the compiler
doesn’t. Rust makes lifetimes explicit, and suddenly you’re annotating
code with <code>'a</code> and <code>'b</code> and wondering why the
compiler won’t accept what you know is safe.</p>
</blockquote>
<hr />
<h2 id="why-this-matters-to-a-c-developer-4">Why This Matters to a C++
Developer</h2>
<p>You already reason about lifetimes. Every time you return a
reference, store a pointer, or pass a callback, you’re making lifetime
decisions.</p>
<p>You know: - Don’t return a reference to a local variable - Don’t
store a pointer to a temporary - Don’t capture a reference in a lambda
that outlives the object</p>
<p>These are rules you’ve internalized. The compiler might warn you, but
it won’t stop you. When you get it wrong, you get dangling pointers,
use-after-free, or crashes that only happen in production.</p>
<p>In practice, you handle this through: - Discipline (“Always check
lifetimes in code review”) - Ownership patterns (RAII, smart pointers) -
Sanitizers (AddressSanitizer, Valgrind) - Testing (and hoping you hit
the bug)</p>
<p>This works most of the time. Until it doesn’t, and you’re debugging a
crash that only reproduces under load, in a codepath you didn’t know
existed.</p>
<hr />
<h2 id="the-c-mental-model-4">The C++ Mental Model</h2>
<p>In C++, lifetimes are <strong>implicit</strong>. You track them
mentally, not in the type system.</p>
<p><strong>Lifetimes are obvious to you.</strong><br />
You know that a reference to a local variable dies when the function
returns. You know that a reference into a vector becomes invalid when
the vector reallocates. The compiler doesn’t track this—you do.</p>
<div class="sourceCode" id="cb27"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span><span class="op">&amp;</span> get_value<span class="op">()</span> <span class="op">{</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> x <span class="op">=</span> <span class="dv">42</span><span class="op">;</span></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> x<span class="op">;</span>  <span class="co">// Dangling reference. Compiler warns, but compiles.</span></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><strong>Lifetimes are tied to scope.</strong><br />
An object lives until the end of its scope. A reference must not outlive
the object it refers to. You ensure this by structuring your code
carefully.</p>
<div class="sourceCode" id="cb28"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> vec <span class="op">=</span> <span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">};</span></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span><span class="op">&amp;</span> ref <span class="op">=</span> vec<span class="op">[</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ref is valid here</span></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a><span class="co">// ref is invalid here (but nothing stops you from using it)</span></span></code></pre></div>
<p><strong>Lifetimes are unchecked.</strong><br />
The compiler doesn’t prove that a reference is valid. It assumes you got
it right. If you didn’t, you get undefined behavior.</p>
<div class="sourceCode" id="cb29"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>string_view get_view<span class="op">()</span> <span class="op">{</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string s <span class="op">=</span> <span class="st">&quot;hello&quot;</span><span class="op">;</span></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">std::</span>string_view<span class="op">(</span>s<span class="op">);</span>  <span class="co">// Dangling view. Compiles.</span></span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><strong>Complex lifetimes are manual.</strong><br />
When you have multiple references with different lifetimes, you track
them yourself. The compiler doesn’t help. You document it, you review
it, and you hope you got it right.</p>
<p>This model works because: - Experienced developers internalize the
rules - Most lifetime bugs are obvious in code review - Sanitizers catch
many (but not all) violations</p>
<hr />
<h2 id="where-the-model-breaks-down-4">Where the Model Breaks Down</h2>
<p>The problem is that <strong>the compiler can’t verify your
reasoning</strong>.</p>
<p><strong>Refactoring breaks lifetimes.</strong><br />
You change a function to return a reference instead of a value. The code
compiles. But now some callers have dangling references. The compiler
doesn’t notice. Your tests might not catch it.</p>
<p><strong>Lifetimes cross abstraction boundaries.</strong><br />
You store a reference in a struct. The struct outlives the object. The
compiler doesn’t track this. You get a use-after-free, but only in a
specific execution order.</p>
<div class="sourceCode" id="cb30"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Cache <span class="op">{</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> <span class="bu">std::</span>string<span class="op">*</span> data<span class="op">;</span>  <span class="co">// Who owns this? How long is it valid?</span></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p><strong>Callbacks and closures are fragile.</strong><br />
You capture a reference in a lambda. The lambda outlives the object. The
compiler doesn’t stop you. You get a crash when the lambda is
invoked.</p>
<div class="sourceCode" id="cb31"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>function<span class="op">&lt;</span><span class="dt">void</span><span class="op">()&gt;</span> make_callback<span class="op">()</span> <span class="op">{</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> x <span class="op">=</span> <span class="dv">42</span><span class="op">;</span></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">[&amp;</span>x<span class="op">]()</span> <span class="op">{</span> <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> x<span class="op">;</span> <span class="op">};</span>  <span class="co">// Dangling capture. Compiles.</span></span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><strong>The cost is deferred.</strong><br />
You write the code, it compiles, and you find out later whether the
lifetimes were correct. By then, the bug is in production, and you’re
debugging a crash with no clear cause.</p>
<p>Rust makes lifetimes explicit. Every reference has a lifetime, and
the compiler tracks it. When you return a reference, the compiler
ensures it doesn’t outlive the object. When you store a reference in a
struct, the compiler ensures the struct doesn’t outlive the
reference.</p>
<p>This requires annotations (<code>'a</code>, <code>'b</code>) that
feel like noise at first. But they’re not noise—they’re the proof the
compiler needs to guarantee your code is safe. Once you understand what
the compiler is checking, the annotations become a tool, not a
burden.</p>
<hr />
<h2 id="rusts-model-4">Rust’s Model</h2>
<p>Rust makes lifetimes explicit when the compiler can’t infer them.
Every reference has a lifetime, and the compiler ensures references
don’t outlive the data they point to.</p>
<p><strong>Lifetimes are usually inferred.</strong><br />
Most of the time, you don’t write lifetime annotations. The compiler
figures them out.</p>
<div class="sourceCode" id="cb32"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> first_element(vec<span class="op">:</span> <span class="op">&amp;</span><span class="dt">Vec</span><span class="op">&lt;</span><span class="dt">i32</span><span class="op">&gt;</span>) <span class="op">-&gt;</span> <span class="op">&amp;</span><span class="dt">i32</span> <span class="op">{</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>    <span class="op">&amp;</span>vec[<span class="dv">0</span>]  <span class="co">// Lifetime inferred: return borrows from vec</span></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The compiler knows the returned reference borrows from
<code>vec</code>, so it can’t outlive <code>vec</code>.</p>
<p><strong>Explicit lifetimes when needed.</strong><br />
When the compiler can’t infer, you annotate with <code>'a</code>,
<code>'b</code>, etc. These aren’t types—they’re names for
lifetimes.</p>
<div class="sourceCode" id="cb33"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> longest<span class="op">&lt;</span><span class="ot">&#39;a</span><span class="op">&gt;</span>(s1<span class="op">:</span> <span class="op">&amp;</span><span class="ot">&#39;a</span> <span class="dt">str</span><span class="op">,</span> s2<span class="op">:</span> <span class="op">&amp;</span><span class="ot">&#39;a</span> <span class="dt">str</span>) <span class="op">-&gt;</span> <span class="op">&amp;</span><span class="ot">&#39;a</span> <span class="dt">str</span> <span class="op">{</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> s1<span class="op">.</span>len() <span class="op">&gt;</span> s2<span class="op">.</span>len() <span class="op">{</span> s1 <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span> s2 <span class="op">}</span></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>This says: “The returned reference has a lifetime valid for as long
as <em>both</em> <code>s1</code> and <code>s2</code> are valid (the
intersection of their lifetimes).” The compiler enforces this:</p>
<div class="sourceCode" id="cb34"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> s1 <span class="op">=</span> <span class="dt">String</span><span class="pp">::</span>from(<span class="st">&quot;long string&quot;</span>)<span class="op">;</span></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> result<span class="op">;</span></span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> s2 <span class="op">=</span> <span class="dt">String</span><span class="pp">::</span>from(<span class="st">&quot;short&quot;</span>)<span class="op">;</span></span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a>        result <span class="op">=</span> longest(<span class="op">&amp;</span>s1<span class="op">,</span> <span class="op">&amp;</span>s2)<span class="op">;</span></span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>  <span class="co">// s2 dropped here</span></span>
<span id="cb34-8"><a href="#cb34-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// println!(&quot;{}&quot;, result);  // Compile error: s2 doesn&#39;t live long enough</span></span>
<span id="cb34-9"><a href="#cb34-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><strong>Structs with references need lifetimes.</strong><br />
If a struct holds a reference, you must annotate the lifetime.</p>
<div class="sourceCode" id="cb35"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Parser<span class="op">&lt;</span><span class="ot">&#39;a</span><span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>    input<span class="op">:</span> <span class="op">&amp;</span><span class="ot">&#39;a</span> <span class="dt">str</span><span class="op">,</span></span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a>    position<span class="op">:</span> <span class="dt">usize</span><span class="op">,</span></span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span><span class="op">&lt;</span><span class="ot">&#39;a</span><span class="op">&gt;</span> Parser<span class="op">&lt;</span><span class="ot">&#39;a</span><span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb35-7"><a href="#cb35-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> new(input<span class="op">:</span> <span class="op">&amp;</span><span class="ot">&#39;a</span> <span class="dt">str</span>) <span class="op">-&gt;</span> <span class="dt">Self</span> <span class="op">{</span></span>
<span id="cb35-8"><a href="#cb35-8" aria-hidden="true" tabindex="-1"></a>        Parser <span class="op">{</span> input<span class="op">,</span> position<span class="op">:</span> <span class="dv">0</span> <span class="op">}</span></span>
<span id="cb35-9"><a href="#cb35-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb35-10"><a href="#cb35-10" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb35-11"><a href="#cb35-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> current(<span class="op">&amp;</span><span class="kw">self</span>) <span class="op">-&gt;</span> <span class="dt">Option</span><span class="op">&lt;</span><span class="dt">char</span><span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb35-12"><a href="#cb35-12" aria-hidden="true" tabindex="-1"></a>        <span class="kw">self</span><span class="op">.</span>input<span class="op">.</span>chars()<span class="op">.</span>nth(<span class="kw">self</span><span class="op">.</span>position)</span>
<span id="cb35-13"><a href="#cb35-13" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Note: This is O(n). A real parser would use byte indices</span></span>
<span id="cb35-14"><a href="#cb35-14" aria-hidden="true" tabindex="-1"></a>        <span class="co">// or iterate with an iterator. This is simplified for clarity.</span></span>
<span id="cb35-15"><a href="#cb35-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb35-16"><a href="#cb35-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The <code>'a</code> says: “This <code>Parser</code> borrows from
<code>input</code>, and can’t outlive it.”</p>
<div class="sourceCode" id="cb36"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> input <span class="op">=</span> <span class="dt">String</span><span class="pp">::</span>from(<span class="st">&quot;hello&quot;</span>)<span class="op">;</span></span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> parser <span class="op">=</span> <span class="pp">Parser::</span>new(<span class="op">&amp;</span>input)<span class="op">;</span></span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">// input can&#39;t be dropped while parser exists</span></span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><strong>Lifetime elision rules.</strong><br />
Rust has rules to infer lifetimes in common cases:</p>
<ol type="1">
<li>Each input reference gets its own lifetime</li>
<li>If there’s one input lifetime, it’s assigned to all output
references</li>
<li>If there’s a <code>&amp;self</code> or <code>&amp;mut self</code>,
its lifetime is assigned to all output references</li>
</ol>
<div class="sourceCode" id="cb37"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="co">// These are equivalent:</span></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> first(vec<span class="op">:</span> <span class="op">&amp;</span><span class="dt">Vec</span><span class="op">&lt;</span><span class="dt">i32</span><span class="op">&gt;</span>) <span class="op">-&gt;</span> <span class="op">&amp;</span><span class="dt">i32</span> <span class="op">{</span> <span class="op">&amp;</span>vec[<span class="dv">0</span>] <span class="op">}</span></span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> first<span class="op">&lt;</span><span class="ot">&#39;a</span><span class="op">&gt;</span>(vec<span class="op">:</span> <span class="op">&amp;</span><span class="ot">&#39;a</span> <span class="dt">Vec</span><span class="op">&lt;</span><span class="dt">i32</span><span class="op">&gt;</span>) <span class="op">-&gt;</span> <span class="op">&amp;</span><span class="ot">&#39;a</span> <span class="dt">i32</span> <span class="op">{</span> <span class="op">&amp;</span>vec[<span class="dv">0</span>] <span class="op">}</span></span></code></pre></div>
<p><strong>Static lifetime for constants.</strong><br />
<code>'static</code> means “lives for the entire program.” String
literals have this lifetime.</p>
<div class="sourceCode" id="cb38"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> get_message() <span class="op">-&gt;</span> <span class="op">&amp;</span><span class="ot">&#39;static</span> <span class="dt">str</span> <span class="op">{</span></span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;This string lives forever&quot;</span></span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<hr />
<h2 id="takeaways-for-c-developers-4">Takeaways for C++ Developers</h2>
<p><strong>Mental model shift:</strong> - Lifetimes are not
types—they’re constraints on how long references are valid - The
compiler tracks lifetimes and prevents dangling references - Annotations
(<code>'a</code>) are names for lifetimes, not durations - Most
lifetimes are inferred—you only annotate when the compiler can’t figure
it out</p>
<p><strong>Rules of thumb:</strong> - Start without lifetime
annotations—add them only when the compiler asks - <code>'a</code> in a
function signature means “all these references are related” - Structs
with references need lifetime annotations - If you’re fighting
lifetimes, consider taking ownership instead of borrowing</p>
<p><strong>Pitfalls:</strong> - Lifetime annotations don’t change
behavior—they document constraints - <code>'static</code> doesn’t mean
“heap-allocated”—it means “lives forever” - You can’t return a reference
to a local variable—the compiler prevents it - Complex lifetime errors
often mean your design needs restructuring</p>
<p>Rust’s lifetime system is what you do mentally in C++ when tracking
pointer validity, but enforced by the compiler.</p>
<hr />
<h1 id="raii-reimagined">6. RAII Reimagined</h1>
<blockquote>
<p>You already know RAII—constructors acquire, destructors release. Rust
uses the same pattern, but ties it to ownership in a way that makes
resource management both more predictable and more restrictive.</p>
</blockquote>
<hr />
<h2 id="why-this-matters-to-a-c-developer-5">Why This Matters to a C++
Developer</h2>
<p>RAII is one of C++’s best ideas. You acquire a resource in a
constructor, release it in a destructor, and the compiler handles
cleanup automatically. No manual <code>free()</code>, no forgetting to
close a file, no leaking mutexes.</p>
<p>You use it everywhere: - <code>std::unique_ptr</code> for memory -
<code>std::lock_guard</code> for mutexes - <code>std::fstream</code> for
files - Custom RAII wrappers for anything else</p>
<p>This works through discipline: - Always use RAII types for resources
- Never call <code>new</code> without a smart pointer - Never acquire a
resource without a corresponding RAII wrapper</p>
<p>When you follow the rules, resource leaks are rare. When you don’t,
you get: - Memory leaks - File descriptor exhaustion - Deadlocks from
unreleased locks - Undefined behavior from double-free</p>
<p>The compiler doesn’t enforce RAII. It’s a pattern, not a language
feature. You choose to use it—or you don’t.</p>
<hr />
<h2 id="the-c-mental-model-5">The C++ Mental Model</h2>
<p>In C++, RAII is a <strong>convention</strong> built on
destructors.</p>
<p><strong>Destructors are guaranteed.</strong><br />
When an object goes out of scope, its destructor runs. This is
deterministic, predictable, and happens in reverse order of
construction.</p>
<div class="sourceCode" id="cb39"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>lock_guard<span class="op">&lt;</span><span class="bu">std::</span>mutex<span class="op">&gt;</span> lock<span class="op">(</span>mtx<span class="op">);</span></span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Critical section</span></span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>  <span class="co">// lock released here, automatically</span></span></code></pre></div>
<p><strong>RAII is opt-in.</strong><br />
You can use raw pointers, manual <code>delete</code>, and explicit
resource management if you want. The language doesn’t force you to use
RAII—it just makes it convenient.</p>
<div class="sourceCode" id="cb40"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span><span class="op">*</span> ptr <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">(</span><span class="dv">42</span><span class="op">);</span>  <span class="co">// No RAII. You must delete manually.</span></span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a><span class="kw">delete</span> ptr<span class="op">;</span></span></code></pre></div>
<p><strong>Ownership is implicit.</strong><br />
A RAII type owns the resource, but the compiler doesn’t track this. You
can copy a <code>unique_ptr</code> (if you disable the copy
constructor), move from it and then use it, or store a raw pointer to
the managed resource.</p>
<div class="sourceCode" id="cb41"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> ptr <span class="op">=</span> <span class="bu">std::</span>make_unique<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;(</span><span class="dv">42</span><span class="op">);</span></span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span><span class="op">*</span> raw <span class="op">=</span> ptr<span class="op">.</span>get<span class="op">();</span></span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a>ptr<span class="op">.</span>reset<span class="op">();</span>  <span class="co">// Resource destroyed</span></span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a><span class="op">*</span>raw <span class="op">=</span> <span class="dv">10</span><span class="op">;</span>    <span class="co">// Dangling pointer. Undefined behavior.</span></span></code></pre></div>
<p><strong>Destructors can fail.</strong><br />
A destructor can throw an exception (though it shouldn’t). If it does
during stack unwinding, your program terminates. You handle this by
making destructors <code>noexcept</code> and logging errors instead of
throwing.</p>
<p>This model works because: - RAII types are well-understood - Smart
pointers are standard library features - Destructors are deterministic
and predictable</p>
<hr />
<h2 id="where-the-model-breaks-down-5">Where the Model Breaks Down</h2>
<p>The problem is that <strong>RAII doesn’t prevent misuse</strong>.</p>
<p><strong>You can bypass RAII.</strong><br />
Nothing stops you from calling <code>new</code> and forgetting to
<code>delete</code>. Nothing stops you from storing a raw pointer to a
RAII-managed resource and using it after the resource is destroyed.</p>
<div class="sourceCode" id="cb42"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>unique_ptr<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> ptr <span class="op">=</span> <span class="bu">std::</span>make_unique<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;(</span><span class="dv">42</span><span class="op">);</span></span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span><span class="op">*</span> raw <span class="op">=</span> ptr<span class="op">.</span>get<span class="op">();</span></span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a>ptr<span class="op">.</span>reset<span class="op">();</span></span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a><span class="op">*</span>raw <span class="op">=</span> <span class="dv">10</span><span class="op">;</span>  <span class="co">// Compiles. Undefined behavior.</span></span></code></pre></div>
<p><strong>Move semantics are unchecked.</strong><br />
You can move from a RAII object and then use it. The compiler doesn’t
stop you. The object is in a valid-but-unspecified state, and using it
is your problem.</p>
<div class="sourceCode" id="cb43"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> ptr <span class="op">=</span> <span class="bu">std::</span>make_unique<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;(</span><span class="dv">42</span><span class="op">);</span></span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> ptr2 <span class="op">=</span> <span class="bu">std::</span>move<span class="op">(</span>ptr<span class="op">);</span></span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a><span class="op">*</span>ptr <span class="op">=</span> <span class="dv">10</span><span class="op">;</span>  <span class="co">// Undefined behavior. Compiles.</span></span></code></pre></div>
<p><strong>Destructors are invisible.</strong><br />
You don’t see when a destructor runs—it just happens. This is usually
good, but it can be surprising. A temporary object is destroyed at the
end of the statement, not the end of the scope.</p>
<div class="sourceCode" id="cb44"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>lock_guard<span class="op">&lt;</span><span class="bu">std::</span>mutex<span class="op">&gt;(</span>mtx<span class="op">);</span>  <span class="co">// Lock acquired and immediately released!</span></span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a><span class="co">// Critical section is NOT protected</span></span></code></pre></div>
<p><strong>Copying RAII types is fragile.</strong><br />
Some RAII types are copyable (<code>shared_ptr</code>), some are
move-only (<code>unique_ptr</code>), and some are neither
(<code>lock_guard</code>). The rules are inconsistent, and the compiler
doesn’t help you understand why.</p>
<p>Rust ties RAII to ownership. Every value has exactly one owner, and
when the owner goes out of scope, the destructor runs. You can’t bypass
this. You can’t use a value after it’s been moved. You can’t copy a RAII
type unless it explicitly implements <code>Clone</code>.</p>
<p>This makes RAII more restrictive—but also more predictable. You don’t
have to remember to use smart pointers. You don’t have to worry about
use-after-move. The compiler enforces the pattern, not your
discipline.</p>
<hr />
<h2 id="rusts-model-5">Rust’s Model</h2>
<p>Rust ties RAII to ownership. Every value has exactly one owner, and
when the owner goes out of scope, the destructor (<code>Drop</code>)
runs. You can’t bypass this.</p>
<p><strong>Drop is automatic and guaranteed.</strong><br />
When a value goes out of scope, its <code>Drop</code> implementation
runs. This is deterministic and predictable.</p>
<div class="sourceCode" id="cb45"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">std::fs::</span>File<span class="op">;</span></span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">std::io::</span><span class="bu">Write</span><span class="op">;</span></span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> write_log(message<span class="op">:</span> <span class="op">&amp;</span><span class="dt">str</span>) <span class="op">-&gt;</span> <span class="pp">std::io::</span><span class="dt">Result</span><span class="op">&lt;</span>()<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb45-5"><a href="#cb45-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">mut</span> file <span class="op">=</span> <span class="pp">File::</span>create(<span class="st">&quot;log.txt&quot;</span>)<span class="op">?;</span></span>
<span id="cb45-6"><a href="#cb45-6" aria-hidden="true" tabindex="-1"></a>    file<span class="op">.</span>write_all(message<span class="op">.</span>as_bytes())<span class="op">?;</span></span>
<span id="cb45-7"><a href="#cb45-7" aria-hidden="true" tabindex="-1"></a>    <span class="cn">Ok</span>(())</span>
<span id="cb45-8"><a href="#cb45-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>  <span class="co">// file.drop() called here automatically</span></span></code></pre></div>
<p>No need for explicit cleanup. The file is closed when
<code>file</code> goes out of scope.</p>
<p><strong>You can’t bypass RAII.</strong><br />
There’s no equivalent to raw <code>new</code> and <code>delete</code>.
Every resource is managed by a type that implements
<code>Drop</code>.</p>
<div class="sourceCode" id="cb46"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> process_data() <span class="op">{</span></span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> data <span class="op">=</span> <span class="pp">vec!</span>[<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span>]<span class="op">;</span>  <span class="co">// Heap allocation</span></span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Use data</span></span>
<span id="cb46-4"><a href="#cb46-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>  <span class="co">// data.drop() called, memory freed</span></span></code></pre></div>
<p>You can’t forget to free memory. The compiler ensures
<code>Drop</code> runs.</p>
<p><strong>Move semantics prevent double-free.</strong><br />
When you move a value, the original owner can’t drop it.</p>
<div class="sourceCode" id="cb47"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> consume(data<span class="op">:</span> <span class="dt">Vec</span><span class="op">&lt;</span><span class="dt">i32</span><span class="op">&gt;</span>) <span class="op">{</span></span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// data is dropped here</span></span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb47-4"><a href="#cb47-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-5"><a href="#cb47-5" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb47-6"><a href="#cb47-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> vec <span class="op">=</span> <span class="pp">vec!</span>[<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span>]<span class="op">;</span></span>
<span id="cb47-7"><a href="#cb47-7" aria-hidden="true" tabindex="-1"></a>    consume(vec)<span class="op">;</span>  <span class="co">// vec moved</span></span>
<span id="cb47-8"><a href="#cb47-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// vec.drop() NOT called here—ownership transferred</span></span>
<span id="cb47-9"><a href="#cb47-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>In C++, you can use a moved-from object and get undefined behavior.
In Rust, the compiler prevents it.</p>
<p><strong>Custom RAII types with Drop.</strong><br />
You implement <code>Drop</code> for custom cleanup logic.</p>
<div class="sourceCode" id="cb48"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">std::sync::</span>Mutex<span class="op">;</span></span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> critical_section(lock<span class="op">:</span> <span class="op">&amp;</span>Mutex<span class="op">&lt;</span><span class="dt">i32</span><span class="op">&gt;</span>) <span class="op">{</span></span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">mut</span> guard <span class="op">=</span> lock<span class="op">.</span>lock()<span class="op">.</span>unwrap()<span class="op">;</span></span>
<span id="cb48-5"><a href="#cb48-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">*</span>guard <span class="op">+=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb48-6"><a href="#cb48-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>  <span class="co">// guard.drop() called here, releasing the lock</span></span></code></pre></div>
<p>The standard library’s <code>MutexGuard</code> implements
<code>Drop</code> to release the lock. You rarely need to implement
custom lock guards.</p>
<p><strong>No copy for RAII types.</strong><br />
Types that manage resources don’t implement <code>Copy</code>. You must
explicitly clone or move.</p>
<div class="sourceCode" id="cb49"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> file <span class="op">=</span> <span class="pp">File::</span>open(<span class="st">&quot;data.txt&quot;</span>)<span class="op">?;</span></span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a><span class="co">// let file2 = file;  // Move, not copy</span></span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a><span class="co">// file is now invalid</span></span>
<span id="cb49-4"><a href="#cb49-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-5"><a href="#cb49-5" aria-hidden="true" tabindex="-1"></a><span class="co">// To share, use Rc or Arc:</span></span>
<span id="cb49-6"><a href="#cb49-6" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">std::rc::</span>Rc<span class="op">;</span></span>
<span id="cb49-7"><a href="#cb49-7" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> data <span class="op">=</span> <span class="pp">Rc::</span>new(<span class="pp">vec!</span>[<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span>])<span class="op">;</span></span>
<span id="cb49-8"><a href="#cb49-8" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> data2 <span class="op">=</span> <span class="pp">Rc::</span>clone(<span class="op">&amp;</span>data)<span class="op">;</span>  <span class="co">// Explicit reference count increment</span></span></code></pre></div>
<p><strong>Drop order is deterministic.</strong><br />
Values are dropped in reverse order of creation, just like C++
destructors.</p>
<div class="sourceCode" id="cb50"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> _a <span class="op">=</span> <span class="dt">String</span><span class="pp">::</span>from(<span class="st">&quot;first&quot;</span>)<span class="op">;</span></span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> _b <span class="op">=</span> <span class="dt">String</span><span class="pp">::</span>from(<span class="st">&quot;second&quot;</span>)<span class="op">;</span></span>
<span id="cb50-4"><a href="#cb50-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> _c <span class="op">=</span> <span class="dt">String</span><span class="pp">::</span>from(<span class="st">&quot;third&quot;</span>)<span class="op">;</span></span>
<span id="cb50-5"><a href="#cb50-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>  <span class="co">// Dropped in order: c, b, a</span></span></code></pre></div>
<hr />
<h2 id="takeaways-for-c-developers-5">Takeaways for C++ Developers</h2>
<p><strong>Mental model shift:</strong> - RAII is mandatory, not
opt-in—every value has a destructor - Move is the default—you can’t use
a value after moving it - No manual <code>delete</code> or
<code>free</code>—the compiler ensures cleanup - <code>Drop</code> is
like a C++ destructor, but tied to ownership</p>
<p><strong>Rules of thumb:</strong> - Resources are managed by types
that implement <code>Drop</code> - Moving transfers ownership—the
original owner can’t drop - Use <code>Rc</code>/<code>Arc</code> for
shared ownership (explicit reference counting) - Implement
<code>Drop</code> for custom cleanup logic</p>
<p><strong>Pitfalls:</strong> - You can’t implement both
<code>Drop</code> and <code>Copy</code>—they’re mutually exclusive (Copy
types must be trivially copyable; Drop types need cleanup logic) -
<code>Drop</code> can’t fail—no exceptions, so handle errors before
dropping - Circular references with <code>Rc</code> cause memory
leaks—use <code>Weak</code> to break cycles - The compiler prevents
use-after-move, unlike C++ <code>std::move</code></p>
<p>Rust’s RAII is what C++ smart pointers try to be, but enforced by the
compiler and tied to ownership.</p>
<hr />
<h1 id="error-handling-without-exceptions">7. Error Handling Without
Exceptions</h1>
<blockquote>
<p>In C++, you throw exceptions for errors and catch them somewhere up
the stack. Rust doesn’t have exceptions—errors are values, and you
handle them explicitly at every step.</p>
</blockquote>
<hr />
<h2 id="why-this-matters-to-a-c-developer-6">Why This Matters to a C++
Developer</h2>
<p>You use exceptions for error handling. When something goes wrong, you
throw. The stack unwinds, destructors run, and control jumps to the
nearest catch block. It’s automatic, it’s clean, and it separates error
handling from normal control flow.</p>
<p>You structure your code around this: - Constructors throw if
initialization fails - Functions throw if they can’t complete - Catch
blocks handle errors at the appropriate level - RAII ensures cleanup
happens during unwinding</p>
<p>This works well for many cases: - Errors propagate automatically -
You don’t clutter normal code with error checks - Destructors guarantee
cleanup</p>
<p>But it has costs: - Exception safety is hard to reason about -
Performance is unpredictable (zero-cost until you throw) - You can’t
tell from a function signature whether it throws - Exceptions across
library boundaries are fragile</p>
<p>In practice, many C++ codebases avoid exceptions entirely. Google’s
style guide bans them. Game engines disable them. Embedded systems can’t
afford them. You use error codes, <code>std::optional</code>, or
<code>std::expected</code> instead.</p>
<hr />
<h2 id="the-c-mental-model-6">The C++ Mental Model</h2>
<p>In C++, exceptions are <strong>invisible control flow</strong>.</p>
<p><strong>Errors propagate automatically.</strong><br />
You throw an exception, and it travels up the stack until someone
catches it. You don’t have to manually check and forward errors at every
level.</p>
<div class="sourceCode" id="cb51"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> process<span class="op">()</span> <span class="op">{</span></span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> file <span class="op">=</span> open_file<span class="op">(</span><span class="st">&quot;data.txt&quot;</span><span class="op">);</span>  <span class="co">// Throws if file doesn&#39;t exist</span></span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// No error checking needed here</span></span>
<span id="cb51-4"><a href="#cb51-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><strong>Error handling is separate from logic.</strong><br />
Your normal code path is clean. Error handling happens in catch blocks,
away from the main logic.</p>
<div class="sourceCode" id="cb52"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a><span class="cf">try</span> <span class="op">{</span></span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a>    step1<span class="op">();</span></span>
<span id="cb52-3"><a href="#cb52-3" aria-hidden="true" tabindex="-1"></a>    step2<span class="op">();</span></span>
<span id="cb52-4"><a href="#cb52-4" aria-hidden="true" tabindex="-1"></a>    step3<span class="op">();</span></span>
<span id="cb52-5"><a href="#cb52-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> <span class="cf">catch</span> <span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>exception<span class="op">&amp;</span> e<span class="op">)</span> <span class="op">{</span></span>
<span id="cb52-6"><a href="#cb52-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Handle all errors here</span></span>
<span id="cb52-7"><a href="#cb52-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><strong>Exceptions are expensive when thrown.</strong><br />
The happy path is fast—no overhead. But when you throw, the cost is
high: stack unwinding, destructor calls, and searching for catch blocks.
This is fine if exceptions are rare.</p>
<p><strong>Exception safety is a discipline.</strong><br />
You must ensure your code is exception-safe: basic guarantee (no leaks),
strong guarantee (rollback on failure), or nothrow guarantee. The
compiler doesn’t enforce this—you do.</p>
<p><strong>Exceptions are invisible in signatures.</strong><br />
A function signature doesn’t tell you what exceptions it might throw
(unless you use <code>noexcept</code>). You have to read the
documentation or the implementation.</p>
<div class="sourceCode" id="cb53"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> process<span class="op">();</span>  <span class="co">// Does this throw? What exceptions? Unknown.</span></span></code></pre></div>
<p>This model works when: - Errors are exceptional (rare) - You can
afford the runtime cost - You trust all code in the call stack to be
exception-safe</p>
<hr />
<h2 id="where-the-model-breaks-down-6">Where the Model Breaks Down</h2>
<p>The problem is that <strong>exceptions are invisible until they’re
not</strong>.</p>
<p><strong>You can’t tell what might fail.</strong><br />
A function call might throw, or it might not. The compiler doesn’t tell
you. You have to know, or you have to assume everything throws.</p>
<div class="sourceCode" id="cb54"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> process<span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>string<span class="op">&amp;</span> data<span class="op">)</span> <span class="op">{</span></span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> result <span class="op">=</span> parse<span class="op">(</span>data<span class="op">);</span>  <span class="co">// Does this throw? Maybe.</span></span>
<span id="cb54-3"><a href="#cb54-3" aria-hidden="true" tabindex="-1"></a>    save<span class="op">(</span>result<span class="op">);</span>               <span class="co">// Does this throw? Probably.</span></span>
<span id="cb54-4"><a href="#cb54-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><strong>Error handling is deferred.</strong><br />
You don’t have to handle errors where they occur. You can let them
propagate. This is convenient, but it means errors can surface far from
their source.</p>
<p><strong>Exception safety is hard.</strong><br />
You must ensure that every operation either completes or leaves the
program in a valid state. This is difficult when exceptions can be
thrown from anywhere.</p>
<div class="sourceCode" id="cb55"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> transfer<span class="op">(</span>Account<span class="op">&amp;</span> from<span class="op">,</span> Account<span class="op">&amp;</span> to<span class="op">,</span> <span class="dt">int</span> amount<span class="op">)</span> <span class="op">{</span></span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true" tabindex="-1"></a>    from<span class="op">.</span>withdraw<span class="op">(</span>amount<span class="op">);</span>  <span class="co">// What if this throws after modifying state?</span></span>
<span id="cb55-3"><a href="#cb55-3" aria-hidden="true" tabindex="-1"></a>    to<span class="op">.</span>deposit<span class="op">(</span>amount<span class="op">);</span>     <span class="co">// What if this throws?</span></span>
<span id="cb55-4"><a href="#cb55-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><strong>Performance is unpredictable.</strong><br />
The happy path is fast, but the error path is slow. If errors are common
(parsing user input, network failures), exceptions become a performance
problem.</p>
<p><strong>Exceptions don’t cross boundaries well.</strong><br />
C APIs don’t understand exceptions. Throwing across a C library is
undefined behavior. You have to catch at the boundary and convert to
error codes.</p>
<p>Rust doesn’t have exceptions. Errors are
values—<code>Result&lt;T, E&gt;</code>—and you handle them explicitly.
Every function that can fail returns a <code>Result</code>. You can’t
ignore it. You can’t let it propagate without acknowledging it.</p>
<p>This is more verbose. You check errors at every step. But it’s also
more explicit: you know exactly what can fail, and you decide how to
handle it. The compiler ensures you don’t ignore errors.</p>
<hr />
<h2 id="rusts-model-6">Rust’s Model</h2>
<p>Rust uses <code>Result&lt;T, E&gt;</code> for recoverable errors and
<code>panic!</code> for unrecoverable errors. Errors are values, and you
handle them explicitly.</p>
<p><strong>Result is an enum.</strong><br />
Functions that can fail return <code>Result&lt;T, E&gt;</code>:</p>
<div class="sourceCode" id="cb56"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">std::fs::</span>File<span class="op">;</span></span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">std::io::</span><span class="op">{</span><span class="kw">self</span><span class="op">,</span> <span class="bu">Read</span><span class="op">};</span></span>
<span id="cb56-3"><a href="#cb56-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-4"><a href="#cb56-4" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> read_config(path<span class="op">:</span> <span class="op">&amp;</span><span class="dt">str</span>) <span class="op">-&gt;</span> <span class="dt">Result</span><span class="op">&lt;</span><span class="dt">String</span><span class="op">,</span> <span class="pp">io::</span><span class="bu">Error</span><span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb56-5"><a href="#cb56-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">mut</span> file <span class="op">=</span> <span class="pp">File::</span>open(path)<span class="op">?;</span>  <span class="co">// ? propagates error</span></span>
<span id="cb56-6"><a href="#cb56-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">mut</span> contents <span class="op">=</span> <span class="dt">String</span><span class="pp">::</span>new()<span class="op">;</span></span>
<span id="cb56-7"><a href="#cb56-7" aria-hidden="true" tabindex="-1"></a>    file<span class="op">.</span>read_to_string(<span class="op">&amp;</span><span class="kw">mut</span> contents)<span class="op">?;</span></span>
<span id="cb56-8"><a href="#cb56-8" aria-hidden="true" tabindex="-1"></a>    <span class="cn">Ok</span>(contents)</span>
<span id="cb56-9"><a href="#cb56-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><code>Result</code> is either <code>Ok(value)</code> or
<code>Err(error)</code>. You must handle it—the compiler won’t let you
ignore it.</p>
<p><strong>The ? operator propagates errors.</strong><br />
Instead of manually checking and returning, use <code>?</code>:</p>
<div class="sourceCode" id="cb57"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> process_file(path<span class="op">:</span> <span class="op">&amp;</span><span class="dt">str</span>) <span class="op">-&gt;</span> <span class="dt">Result</span><span class="op">&lt;</span>()<span class="op">,</span> <span class="pp">io::</span><span class="bu">Error</span><span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> contents <span class="op">=</span> read_config(path)<span class="op">?;</span>  <span class="co">// Returns early if error</span></span>
<span id="cb57-3"><a href="#cb57-3" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;Config: {}&quot;</span><span class="op">,</span> contents)<span class="op">;</span></span>
<span id="cb57-4"><a href="#cb57-4" aria-hidden="true" tabindex="-1"></a>    <span class="cn">Ok</span>(())</span>
<span id="cb57-5"><a href="#cb57-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>This is equivalent to:</p>
<div class="sourceCode" id="cb58"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> contents <span class="op">=</span> <span class="cf">match</span> read_config(path) <span class="op">{</span></span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true" tabindex="-1"></a>    <span class="cn">Ok</span>(c) <span class="op">=&gt;</span> c<span class="op">,</span></span>
<span id="cb58-3"><a href="#cb58-3" aria-hidden="true" tabindex="-1"></a>    <span class="cn">Err</span>(e) <span class="op">=&gt;</span> <span class="cf">return</span> <span class="cn">Err</span>(e)<span class="op">,</span></span>
<span id="cb58-4"><a href="#cb58-4" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p><strong>Pattern matching for error handling.</strong><br />
You can handle different errors differently:</p>
<div class="sourceCode" id="cb59"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">std::fs::</span>File<span class="op">;</span></span>
<span id="cb59-2"><a href="#cb59-2" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">std::io::</span>ErrorKind<span class="op">;</span></span>
<span id="cb59-3"><a href="#cb59-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-4"><a href="#cb59-4" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> open_or_create(path<span class="op">:</span> <span class="op">&amp;</span><span class="dt">str</span>) <span class="op">-&gt;</span> <span class="dt">Result</span><span class="op">&lt;</span>File<span class="op">,</span> <span class="pp">io::</span><span class="bu">Error</span><span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb59-5"><a href="#cb59-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">match</span> <span class="pp">File::</span>open(path) <span class="op">{</span></span>
<span id="cb59-6"><a href="#cb59-6" aria-hidden="true" tabindex="-1"></a>        <span class="cn">Ok</span>(file) <span class="op">=&gt;</span> <span class="cn">Ok</span>(file)<span class="op">,</span></span>
<span id="cb59-7"><a href="#cb59-7" aria-hidden="true" tabindex="-1"></a>        <span class="cn">Err</span>(error) <span class="op">=&gt;</span> <span class="cf">match</span> error<span class="op">.</span>kind() <span class="op">{</span></span>
<span id="cb59-8"><a href="#cb59-8" aria-hidden="true" tabindex="-1"></a>            <span class="pp">ErrorKind::</span>NotFound <span class="op">=&gt;</span> <span class="pp">File::</span>create(path)<span class="op">,</span></span>
<span id="cb59-9"><a href="#cb59-9" aria-hidden="true" tabindex="-1"></a>            other_error <span class="op">=&gt;</span> <span class="cn">Err</span>(<span class="pp">io::</span><span class="bu">Error</span><span class="pp">::</span>new(other_error<span class="op">,</span> <span class="st">&quot;Failed to open&quot;</span>))<span class="op">,</span></span>
<span id="cb59-10"><a href="#cb59-10" aria-hidden="true" tabindex="-1"></a>        <span class="op">},</span></span>
<span id="cb59-11"><a href="#cb59-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb59-12"><a href="#cb59-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><strong>Custom error types.</strong><br />
You can define your own error types:</p>
<div class="sourceCode" id="cb60"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">std::</span>fmt<span class="op">;</span></span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb60-3"><a href="#cb60-3" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>derive<span class="at">(</span><span class="bu">Debug</span><span class="at">)]</span></span>
<span id="cb60-4"><a href="#cb60-4" aria-hidden="true" tabindex="-1"></a><span class="kw">enum</span> ParseError <span class="op">{</span></span>
<span id="cb60-5"><a href="#cb60-5" aria-hidden="true" tabindex="-1"></a>    InvalidFormat<span class="op">,</span></span>
<span id="cb60-6"><a href="#cb60-6" aria-hidden="true" tabindex="-1"></a>    MissingField(<span class="dt">String</span>)<span class="op">,</span></span>
<span id="cb60-7"><a href="#cb60-7" aria-hidden="true" tabindex="-1"></a>    OutOfRange(<span class="dt">i32</span>)<span class="op">,</span></span>
<span id="cb60-8"><a href="#cb60-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb60-9"><a href="#cb60-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb60-10"><a href="#cb60-10" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span> <span class="pp">fmt::</span><span class="bu">Display</span> <span class="cf">for</span> ParseError <span class="op">{</span></span>
<span id="cb60-11"><a href="#cb60-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> fmt(<span class="op">&amp;</span><span class="kw">self</span><span class="op">,</span> f<span class="op">:</span> <span class="op">&amp;</span><span class="kw">mut</span> <span class="pp">fmt::</span>Formatter) <span class="op">-&gt;</span> <span class="pp">fmt::</span><span class="dt">Result</span> <span class="op">{</span></span>
<span id="cb60-12"><a href="#cb60-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">match</span> <span class="kw">self</span> <span class="op">{</span></span>
<span id="cb60-13"><a href="#cb60-13" aria-hidden="true" tabindex="-1"></a>            <span class="pp">ParseError::</span>InvalidFormat <span class="op">=&gt;</span> <span class="pp">write!</span>(f<span class="op">,</span> <span class="st">&quot;Invalid format&quot;</span>)<span class="op">,</span></span>
<span id="cb60-14"><a href="#cb60-14" aria-hidden="true" tabindex="-1"></a>            <span class="pp">ParseError::</span>MissingField(field) <span class="op">=&gt;</span> <span class="pp">write!</span>(f<span class="op">,</span> <span class="st">&quot;Missing field: {}&quot;</span><span class="op">,</span> field)<span class="op">,</span></span>
<span id="cb60-15"><a href="#cb60-15" aria-hidden="true" tabindex="-1"></a>            <span class="pp">ParseError::</span>OutOfRange(val) <span class="op">=&gt;</span> <span class="pp">write!</span>(f<span class="op">,</span> <span class="st">&quot;Value out of range: {}&quot;</span><span class="op">,</span> val)<span class="op">,</span></span>
<span id="cb60-16"><a href="#cb60-16" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb60-17"><a href="#cb60-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb60-18"><a href="#cb60-18" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb60-19"><a href="#cb60-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb60-20"><a href="#cb60-20" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span> <span class="pp">std::error::</span><span class="bu">Error</span> <span class="cf">for</span> ParseError <span class="op">{}</span></span>
<span id="cb60-21"><a href="#cb60-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb60-22"><a href="#cb60-22" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> parse_data(input<span class="op">:</span> <span class="op">&amp;</span><span class="dt">str</span>) <span class="op">-&gt;</span> <span class="dt">Result</span><span class="op">&lt;</span><span class="dt">i32</span><span class="op">,</span> ParseError<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb60-23"><a href="#cb60-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> input<span class="op">.</span>is_empty() <span class="op">{</span></span>
<span id="cb60-24"><a href="#cb60-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="cn">Err</span>(<span class="pp">ParseError::</span>InvalidFormat)<span class="op">;</span></span>
<span id="cb60-25"><a href="#cb60-25" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb60-26"><a href="#cb60-26" aria-hidden="true" tabindex="-1"></a>    input<span class="op">.</span>parse()<span class="op">.</span>map_err(<span class="op">|</span>_<span class="op">|</span> <span class="pp">ParseError::</span>InvalidFormat)</span>
<span id="cb60-27"><a href="#cb60-27" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Note: In practice, most Rust code uses the <code>thiserror</code>
crate to derive these implementations automatically. The manual
implementation above shows what’s happening under the hood.</p>
<p><strong>Panic for unrecoverable errors.</strong><br />
Use <code>panic!</code> for bugs, not for expected errors:</p>
<div class="sourceCode" id="cb61"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> divide(a<span class="op">:</span> <span class="dt">i32</span><span class="op">,</span> b<span class="op">:</span> <span class="dt">i32</span>) <span class="op">-&gt;</span> <span class="dt">i32</span> <span class="op">{</span></span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> b <span class="op">==</span> <span class="dv">0</span> <span class="op">{</span></span>
<span id="cb61-3"><a href="#cb61-3" aria-hidden="true" tabindex="-1"></a>        <span class="pp">panic!</span>(<span class="st">&quot;Division by zero - this is a programming error&quot;</span>)<span class="op">;</span></span>
<span id="cb61-4"><a href="#cb61-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb61-5"><a href="#cb61-5" aria-hidden="true" tabindex="-1"></a>    a <span class="op">/</span> b</span>
<span id="cb61-6"><a href="#cb61-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb61-7"><a href="#cb61-7" aria-hidden="true" tabindex="-1"></a><span class="co">// Use panic for programming errors (bugs), not for expected failures</span></span></code></pre></div>
<p><strong>Combinators for error handling.</strong><br />
<code>Result</code> has methods for common patterns:</p>
<div class="sourceCode" id="cb62"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> parse_number(s<span class="op">:</span> <span class="op">&amp;</span><span class="dt">str</span>) <span class="op">-&gt;</span> <span class="dt">Result</span><span class="op">&lt;</span><span class="dt">i32</span><span class="op">,</span> <span class="pp">std::num::</span>ParseIntError<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb62-2"><a href="#cb62-2" aria-hidden="true" tabindex="-1"></a>    s<span class="op">.</span><span class="pp">parse::</span><span class="op">&lt;</span><span class="dt">i32</span><span class="op">&gt;</span>()</span>
<span id="cb62-3"><a href="#cb62-3" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>map(<span class="op">|</span>n<span class="op">|</span> n <span class="op">*</span> <span class="dv">2</span>)  <span class="co">// Transform success value</span></span>
<span id="cb62-4"><a href="#cb62-4" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>or_else(<span class="op">|</span>_<span class="op">|</span> <span class="cn">Ok</span>(<span class="dv">0</span>))  <span class="co">// Provide default on error</span></span>
<span id="cb62-5"><a href="#cb62-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<hr />
<h2 id="takeaways-for-c-developers-6">Takeaways for C++ Developers</h2>
<p><strong>Mental model shift:</strong> - Errors are values
(<code>Result&lt;T, E&gt;</code>), not control flow (exceptions) - You
must handle errors explicitly—the compiler enforces it - <code>?</code>
propagates errors up the call stack (like <code>throw</code>, but
explicit) - <code>panic!</code> is for bugs, not expected errors</p>
<p><strong>Rules of thumb:</strong> - Return
<code>Result&lt;T, E&gt;</code> for functions that can fail - Use
<code>?</code> to propagate errors up the call stack - Use pattern
matching to handle different error cases - Use <code>panic!</code> for
invariant violations, not for expected failures</p>
<p><strong>Pitfalls:</strong> - Don’t use <code>unwrap()</code> in
production—it panics on error - <code>expect("message")</code> is better
than <code>unwrap()</code> for debugging - Error handling is more
verbose than exceptions—this is intentional - You can’t ignore
<code>Result</code>—the compiler warns if you don’t use it</p>
<p>Rust’s error handling is explicit and visible in function signatures.
The cost is verbosity; the benefit is that you know exactly what can
fail.</p>
<hr />
<h1 id="traits-vs-templates">8. Traits vs Templates</h1>
<blockquote>
<p>In C++, templates are duck-typed—if it compiles, it works. Rust
traits are explicit contracts, and suddenly you’re declaring interfaces
for generic code that would “just work” in C++.</p>
</blockquote>
<hr />
<h2 id="why-this-matters-to-a-c-developer-7">Why This Matters to a C++
Developer</h2>
<p>You use templates for generic code. You write a function that works
with any type that supports the operations you need. The compiler checks
this when you instantiate the template—not when you define it.</p>
<div class="sourceCode" id="cb63"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb63-2"><a href="#cb63-2" aria-hidden="true" tabindex="-1"></a>T add<span class="op">(</span>T a<span class="op">,</span> T b<span class="op">)</span> <span class="op">{</span></span>
<span id="cb63-3"><a href="#cb63-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> a <span class="op">+</span> b<span class="op">;</span>  <span class="co">// Works if T has operator+</span></span>
<span id="cb63-4"><a href="#cb63-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>This is powerful: - No explicit interface declarations - Works with
any type that fits - Compiler generates specialized code for each
instantiation</p>
<p>You don’t declare “this type must support addition”—you just use
addition, and the compiler figures it out. If the type doesn’t support
it, you get a compile error at the call site.</p>
<p>This works through: - Duck typing (“if it quacks like a duck…”) -
SFINAE for conditional compilation - Concepts (C++20) for explicit
constraints (if you use them)</p>
<p>The cost is: - Error messages that span hundreds of lines - No way to
see what operations a template requires - Accidental interface
coupling</p>
<hr />
<h2 id="the-c-mental-model-7">The C++ Mental Model</h2>
<p>In C++, templates are <strong>structural</strong>—they care about
what you can do, not what you claim to be.</p>
<p><strong>Interfaces are implicit.</strong><br />
A template doesn’t declare what operations it needs—it just uses them.
If the type supports those operations, it works. If not, you get a
compile error.</p>
<div class="sourceCode" id="cb64"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb64-2"><a href="#cb64-2" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> process<span class="op">(</span>T<span class="op">&amp;</span> container<span class="op">)</span> <span class="op">{</span></span>
<span id="cb64-3"><a href="#cb64-3" aria-hidden="true" tabindex="-1"></a>    container<span class="op">.</span>push_back<span class="op">(</span><span class="dv">42</span><span class="op">);</span>  <span class="co">// Requires push_back method</span></span>
<span id="cb64-4"><a href="#cb64-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><strong>Constraints are optional.</strong><br />
You can use SFINAE or concepts to constrain templates, but most code
doesn’t. The template just tries to compile, and fails if it can’t.</p>
<p><strong>Instantiation is late.</strong><br />
The compiler checks the template when you use it, not when you define
it. This means errors appear at the call site, not at the
definition.</p>
<div class="sourceCode" id="cb65"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb65-2"><a href="#cb65-2" aria-hidden="true" tabindex="-1"></a>T multiply<span class="op">(</span>T a<span class="op">,</span> T b<span class="op">)</span> <span class="op">{</span></span>
<span id="cb65-3"><a href="#cb65-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> a <span class="op">*</span> b<span class="op">;</span></span>
<span id="cb65-4"><a href="#cb65-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb65-5"><a href="#cb65-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-6"><a href="#cb65-6" aria-hidden="true" tabindex="-1"></a><span class="co">// Error appears here, not in the template definition</span></span>
<span id="cb65-7"><a href="#cb65-7" aria-hidden="true" tabindex="-1"></a>multiply<span class="op">(</span><span class="bu">std::</span>string<span class="op">(</span><span class="st">&quot;hello&quot;</span><span class="op">),</span> <span class="bu">std::</span>string<span class="op">(</span><span class="st">&quot;world&quot;</span><span class="op">));</span></span></code></pre></div>
<p><strong>Specialization is powerful.</strong><br />
You can specialize templates for specific types, providing completely
different implementations. The compiler picks the best match.</p>
<div class="sourceCode" id="cb66"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb66-2"><a href="#cb66-2" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> print<span class="op">(</span>T value<span class="op">)</span> <span class="op">{</span> <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> value<span class="op">;</span> <span class="op">}</span></span>
<span id="cb66-3"><a href="#cb66-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-4"><a href="#cb66-4" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;&gt;</span></span>
<span id="cb66-5"><a href="#cb66-5" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> print<span class="op">&lt;</span><span class="dt">bool</span><span class="op">&gt;(</span><span class="dt">bool</span> value<span class="op">)</span> <span class="op">{</span> <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="op">(</span>value <span class="op">?</span> <span class="st">&quot;true&quot;</span> <span class="op">:</span> <span class="st">&quot;false&quot;</span><span class="op">);</span> <span class="op">}</span></span></code></pre></div>
<p>This model is flexible: - You don’t have to declare interfaces
upfront - Templates work with any type that fits - You can specialize
for specific cases</p>
<hr />
<h2 id="where-the-model-breaks-down-7">Where the Model Breaks Down</h2>
<p>The problem is that <strong>templates hide their
requirements</strong>.</p>
<p><strong>Error messages are incomprehensible.</strong><br />
When a template fails to compile, you get errors deep in the
implementation, not at the interface. The error message shows you what
went wrong, but not what the template actually requires.</p>
<div class="sourceCode" id="cb67"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb67-2"><a href="#cb67-2" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> process<span class="op">(</span>T<span class="op">&amp;</span> container<span class="op">)</span> <span class="op">{</span></span>
<span id="cb67-3"><a href="#cb67-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> it <span class="op">=</span> container<span class="op">.</span>begin<span class="op">();</span></span>
<span id="cb67-4"><a href="#cb67-4" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>sort<span class="op">(</span>it<span class="op">,</span> container<span class="op">.</span>end<span class="op">());</span></span>
<span id="cb67-5"><a href="#cb67-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb67-6"><a href="#cb67-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-7"><a href="#cb67-7" aria-hidden="true" tabindex="-1"></a><span class="co">// Error: no matching function for call to &#39;sort&#39;</span></span>
<span id="cb67-8"><a href="#cb67-8" aria-hidden="true" tabindex="-1"></a><span class="co">// (because std::list doesn&#39;t have random-access iterators)</span></span>
<span id="cb67-9"><a href="#cb67-9" aria-hidden="true" tabindex="-1"></a><span class="co">// But the error doesn&#39;t say &quot;T must have random-access iterators&quot;</span></span></code></pre></div>
<p><strong>Interfaces are accidental.</strong><br />
A template’s interface is whatever operations it happens to use. If you
refactor the implementation, the interface changes. Callers break, even
though you didn’t intend to change the interface.</p>
<p><strong>Constraints are hard to express.</strong><br />
SFINAE is arcane. Concepts (C++20) help, but they’re verbose and not
widely used yet. Most templates just try to compile and fail with
cryptic errors.</p>
<p><strong>Instantiation bloat.</strong><br />
Every instantiation generates new code. If you instantiate a template
with 10 types, you get 10 copies of the code. This increases binary size
and compile time.</p>
<p><strong>No separate compilation.</strong><br />
Templates must be defined in headers. You can’t compile them separately.
This slows down builds and exposes implementation details.</p>
<p>Rust uses traits—explicit interfaces for generic code. A trait
declares what operations a type must support. A generic function
declares which traits it requires. The compiler checks this at the
definition, not at the call site.</p>
<p>This is more verbose. You have to declare traits, implement them for
your types, and specify trait bounds on generic functions. But it’s also
more explicit: you know exactly what a generic function requires, and
errors point to the interface, not the implementation.</p>
<hr />
<h2 id="rusts-model-7">Rust’s Model</h2>
<p>Rust uses traits—explicit interfaces for generic code. A trait
declares what operations a type must support, and generic functions
declare which traits they require.</p>
<p><strong>Traits are explicit interfaces.</strong><br />
A trait defines a set of methods:</p>
<div class="sourceCode" id="cb68"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb68-1"><a href="#cb68-1" aria-hidden="true" tabindex="-1"></a><span class="kw">trait</span> Serialize <span class="op">{</span></span>
<span id="cb68-2"><a href="#cb68-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> to_bytes(<span class="op">&amp;</span><span class="kw">self</span>) <span class="op">-&gt;</span> <span class="dt">Vec</span><span class="op">&lt;</span><span class="dt">u8</span><span class="op">&gt;;</span></span>
<span id="cb68-3"><a href="#cb68-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> from_bytes(data<span class="op">:</span> <span class="op">&amp;</span>[<span class="dt">u8</span>]) <span class="op">-&gt;</span> <span class="dt">Result</span><span class="op">&lt;</span><span class="dt">Self</span><span class="op">,</span> <span class="dt">Box</span><span class="op">&lt;</span><span class="kw">dyn</span> <span class="pp">std::error::</span><span class="bu">Error</span><span class="op">&gt;&gt;</span> </span>
<span id="cb68-4"><a href="#cb68-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> <span class="dt">Self</span><span class="op">:</span> <span class="bu">Sized</span><span class="op">;</span></span>
<span id="cb68-5"><a href="#cb68-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Types implement traits explicitly:</p>
<div class="sourceCode" id="cb69"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Config <span class="op">{</span></span>
<span id="cb69-2"><a href="#cb69-2" aria-hidden="true" tabindex="-1"></a>    host<span class="op">:</span> <span class="dt">String</span><span class="op">,</span></span>
<span id="cb69-3"><a href="#cb69-3" aria-hidden="true" tabindex="-1"></a>    port<span class="op">:</span> <span class="dt">u16</span><span class="op">,</span></span>
<span id="cb69-4"><a href="#cb69-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb69-5"><a href="#cb69-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb69-6"><a href="#cb69-6" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span> Serialize <span class="cf">for</span> Config <span class="op">{</span></span>
<span id="cb69-7"><a href="#cb69-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> to_bytes(<span class="op">&amp;</span><span class="kw">self</span>) <span class="op">-&gt;</span> <span class="dt">Vec</span><span class="op">&lt;</span><span class="dt">u8</span><span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb69-8"><a href="#cb69-8" aria-hidden="true" tabindex="-1"></a>        <span class="pp">format!</span>(<span class="st">&quot;{}:{}&quot;</span><span class="op">,</span> <span class="kw">self</span><span class="op">.</span>host<span class="op">,</span> <span class="kw">self</span><span class="op">.</span>port)<span class="op">.</span>into_bytes()</span>
<span id="cb69-9"><a href="#cb69-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb69-10"><a href="#cb69-10" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb69-11"><a href="#cb69-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> from_bytes(data<span class="op">:</span> <span class="op">&amp;</span>[<span class="dt">u8</span>]) <span class="op">-&gt;</span> <span class="dt">Result</span><span class="op">&lt;</span><span class="dt">Self</span><span class="op">,</span> <span class="dt">Box</span><span class="op">&lt;</span><span class="kw">dyn</span> <span class="pp">std::error::</span><span class="bu">Error</span><span class="op">&gt;&gt;</span> <span class="op">{</span></span>
<span id="cb69-12"><a href="#cb69-12" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> s <span class="op">=</span> <span class="dt">String</span><span class="pp">::</span>from_utf8(data<span class="op">.</span>to_vec())<span class="op">?;</span></span>
<span id="cb69-13"><a href="#cb69-13" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> parts<span class="op">:</span> <span class="dt">Vec</span><span class="op">&lt;&amp;</span><span class="dt">str</span><span class="op">&gt;</span> <span class="op">=</span> s<span class="op">.</span>split(<span class="ch">&#39;:&#39;</span>)<span class="op">.</span>collect()<span class="op">;</span></span>
<span id="cb69-14"><a href="#cb69-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> parts<span class="op">.</span>len() <span class="op">!=</span> <span class="dv">2</span> <span class="op">{</span></span>
<span id="cb69-15"><a href="#cb69-15" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="cn">Err</span>(<span class="st">&quot;Invalid format&quot;</span><span class="op">.</span>into())<span class="op">;</span></span>
<span id="cb69-16"><a href="#cb69-16" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb69-17"><a href="#cb69-17" aria-hidden="true" tabindex="-1"></a>        <span class="cn">Ok</span>(Config <span class="op">{</span></span>
<span id="cb69-18"><a href="#cb69-18" aria-hidden="true" tabindex="-1"></a>            host<span class="op">:</span> parts[<span class="dv">0</span>]<span class="op">.</span>to_string()<span class="op">,</span></span>
<span id="cb69-19"><a href="#cb69-19" aria-hidden="true" tabindex="-1"></a>            port<span class="op">:</span> parts[<span class="dv">1</span>]<span class="op">.</span>parse()<span class="op">?,</span></span>
<span id="cb69-20"><a href="#cb69-20" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span>)</span>
<span id="cb69-21"><a href="#cb69-21" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb69-22"><a href="#cb69-22" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><strong>Generic functions use trait bounds.</strong><br />
You declare what traits a generic type must implement:</p>
<div class="sourceCode" id="cb70"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb70-1"><a href="#cb70-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> save_to_file<span class="op">&lt;</span>T<span class="op">:</span> Serialize<span class="op">&gt;</span>(item<span class="op">:</span> <span class="op">&amp;</span>T<span class="op">,</span> path<span class="op">:</span> <span class="op">&amp;</span><span class="dt">str</span>) <span class="op">-&gt;</span> <span class="pp">std::io::</span><span class="dt">Result</span><span class="op">&lt;</span>()<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb70-2"><a href="#cb70-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> bytes <span class="op">=</span> item<span class="op">.</span>to_bytes()<span class="op">;</span></span>
<span id="cb70-3"><a href="#cb70-3" aria-hidden="true" tabindex="-1"></a>    <span class="pp">std::fs::</span>write(path<span class="op">,</span> bytes)</span>
<span id="cb70-4"><a href="#cb70-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>This says: “<code>T</code> must implement <code>Serialize</code>.”
The compiler checks this at the definition, not at the call site.</p>
<p><strong>Multiple trait bounds.</strong><br />
You can require multiple traits:</p>
<div class="sourceCode" id="cb71"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb71-1"><a href="#cb71-1" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">std::fmt::</span><span class="bu">Debug</span><span class="op">;</span></span>
<span id="cb71-2"><a href="#cb71-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb71-3"><a href="#cb71-3" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> log_and_save<span class="op">&lt;</span>T<span class="op">:</span> Serialize <span class="op">+</span> <span class="bu">Debug</span><span class="op">&gt;</span>(item<span class="op">:</span> <span class="op">&amp;</span>T<span class="op">,</span> path<span class="op">:</span> <span class="op">&amp;</span><span class="dt">str</span>) <span class="op">-&gt;</span> <span class="pp">std::io::</span><span class="dt">Result</span><span class="op">&lt;</span>()<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb71-4"><a href="#cb71-4" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;Saving: {:?}&quot;</span><span class="op">,</span> item)<span class="op">;</span></span>
<span id="cb71-5"><a href="#cb71-5" aria-hidden="true" tabindex="-1"></a>    save_to_file(item<span class="op">,</span> path)</span>
<span id="cb71-6"><a href="#cb71-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Or use <code>where</code> clauses for readability:</p>
<div class="sourceCode" id="cb72"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb72-1"><a href="#cb72-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> process<span class="op">&lt;</span>T<span class="op">&gt;</span>(item<span class="op">:</span> T) <span class="op">-&gt;</span> <span class="dt">Result</span><span class="op">&lt;</span>()<span class="op">,</span> <span class="dt">String</span><span class="op">&gt;</span></span>
<span id="cb72-2"><a href="#cb72-2" aria-hidden="true" tabindex="-1"></a><span class="kw">where</span></span>
<span id="cb72-3"><a href="#cb72-3" aria-hidden="true" tabindex="-1"></a>    T<span class="op">:</span> Serialize <span class="op">+</span> <span class="bu">Debug</span> <span class="op">+</span> <span class="bu">Clone</span><span class="op">,</span></span>
<span id="cb72-4"><a href="#cb72-4" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb72-5"><a href="#cb72-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Implementation</span></span>
<span id="cb72-6"><a href="#cb72-6" aria-hidden="true" tabindex="-1"></a>    <span class="cn">Ok</span>(())</span>
<span id="cb72-7"><a href="#cb72-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><strong>Trait objects for dynamic dispatch.</strong><br />
When you need runtime polymorphism, use trait objects:</p>
<div class="sourceCode" id="cb73"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb73-1"><a href="#cb73-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> process_items(items<span class="op">:</span> <span class="op">&amp;</span>[<span class="dt">Box</span><span class="op">&lt;</span><span class="kw">dyn</span> Serialize<span class="op">&gt;</span>]) <span class="op">{</span></span>
<span id="cb73-2"><a href="#cb73-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> item <span class="kw">in</span> items <span class="op">{</span></span>
<span id="cb73-3"><a href="#cb73-3" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> bytes <span class="op">=</span> item<span class="op">.</span>to_bytes()<span class="op">;</span></span>
<span id="cb73-4"><a href="#cb73-4" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Process bytes</span></span>
<span id="cb73-5"><a href="#cb73-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb73-6"><a href="#cb73-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><code>dyn Serialize</code> is a trait object—like a C++ virtual
function, but explicit. The cost (vtable lookup) is visible in the
type.</p>
<p><strong>Associated types for cleaner signatures.</strong><br />
Traits can have associated types:</p>
<div class="sourceCode" id="cb74"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb74-1"><a href="#cb74-1" aria-hidden="true" tabindex="-1"></a><span class="kw">trait</span> Parser <span class="op">{</span></span>
<span id="cb74-2"><a href="#cb74-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">type</span> Output<span class="op">;</span></span>
<span id="cb74-3"><a href="#cb74-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">type</span> Error<span class="op">;</span></span>
<span id="cb74-4"><a href="#cb74-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb74-5"><a href="#cb74-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> parse(<span class="op">&amp;</span><span class="kw">self</span><span class="op">,</span> input<span class="op">:</span> <span class="op">&amp;</span><span class="dt">str</span>) <span class="op">-&gt;</span> <span class="dt">Result</span><span class="op">&lt;</span><span class="dt">Self</span><span class="pp">::</span>Output<span class="op">,</span> <span class="dt">Self</span><span class="pp">::</span><span class="bu">Error</span><span class="op">&gt;;</span></span>
<span id="cb74-6"><a href="#cb74-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb74-7"><a href="#cb74-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb74-8"><a href="#cb74-8" aria-hidden="true" tabindex="-1"></a><span class="co">// Using serde_json crate (external dependency)</span></span>
<span id="cb74-9"><a href="#cb74-9" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> JsonParser<span class="op">;</span></span>
<span id="cb74-10"><a href="#cb74-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb74-11"><a href="#cb74-11" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span> Parser <span class="cf">for</span> JsonParser <span class="op">{</span></span>
<span id="cb74-12"><a href="#cb74-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">type</span> Output <span class="op">=</span> <span class="pp">serde_json::</span>Value<span class="op">;</span></span>
<span id="cb74-13"><a href="#cb74-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">type</span> Error <span class="op">=</span> <span class="pp">serde_json::</span><span class="bu">Error</span><span class="op">;</span></span>
<span id="cb74-14"><a href="#cb74-14" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb74-15"><a href="#cb74-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> parse(<span class="op">&amp;</span><span class="kw">self</span><span class="op">,</span> input<span class="op">:</span> <span class="op">&amp;</span><span class="dt">str</span>) <span class="op">-&gt;</span> <span class="dt">Result</span><span class="op">&lt;</span><span class="dt">Self</span><span class="pp">::</span>Output<span class="op">,</span> <span class="dt">Self</span><span class="pp">::</span><span class="bu">Error</span><span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb74-16"><a href="#cb74-16" aria-hidden="true" tabindex="-1"></a>        <span class="pp">serde_json::</span>from_str(input)</span>
<span id="cb74-17"><a href="#cb74-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb74-18"><a href="#cb74-18" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><strong>Default implementations.</strong><br />
Traits can provide default method implementations:</p>
<div class="sourceCode" id="cb75"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb75-1"><a href="#cb75-1" aria-hidden="true" tabindex="-1"></a><span class="kw">trait</span> Logger <span class="op">{</span></span>
<span id="cb75-2"><a href="#cb75-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> log(<span class="op">&amp;</span><span class="kw">self</span><span class="op">,</span> message<span class="op">:</span> <span class="op">&amp;</span><span class="dt">str</span>) <span class="op">{</span></span>
<span id="cb75-3"><a href="#cb75-3" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;[LOG] {}&quot;</span><span class="op">,</span> message)<span class="op">;</span></span>
<span id="cb75-4"><a href="#cb75-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb75-5"><a href="#cb75-5" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb75-6"><a href="#cb75-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> error(<span class="op">&amp;</span><span class="kw">self</span><span class="op">,</span> message<span class="op">:</span> <span class="op">&amp;</span><span class="dt">str</span>) <span class="op">{</span></span>
<span id="cb75-7"><a href="#cb75-7" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;[ERROR] {}&quot;</span><span class="op">,</span> message)<span class="op">;</span></span>
<span id="cb75-8"><a href="#cb75-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb75-9"><a href="#cb75-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb75-10"><a href="#cb75-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb75-11"><a href="#cb75-11" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> FileLogger<span class="op">;</span></span>
<span id="cb75-12"><a href="#cb75-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb75-13"><a href="#cb75-13" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span> Logger <span class="cf">for</span> FileLogger <span class="op">{</span></span>
<span id="cb75-14"><a href="#cb75-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Use default log(), override error()</span></span>
<span id="cb75-15"><a href="#cb75-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> error(<span class="op">&amp;</span><span class="kw">self</span><span class="op">,</span> message<span class="op">:</span> <span class="op">&amp;</span><span class="dt">str</span>) <span class="op">{</span></span>
<span id="cb75-16"><a href="#cb75-16" aria-hidden="true" tabindex="-1"></a>        <span class="pp">eprintln!</span>(<span class="st">&quot;[FILE ERROR] {}&quot;</span><span class="op">,</span> message)<span class="op">;</span></span>
<span id="cb75-17"><a href="#cb75-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb75-18"><a href="#cb75-18" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<hr />
<h2 id="takeaways-for-c-developers-7">Takeaways for C++ Developers</h2>
<p><strong>Mental model shift:</strong> - Traits are explicit
interfaces—you declare what you need - Generic functions are checked at
definition, not instantiation - Trait bounds replace SFINAE and concepts
- Trait objects (<code>dyn Trait</code>) are explicit dynamic
dispatch</p>
<p><strong>Rules of thumb:</strong> - Define traits for interfaces, not
just for generic code - Use trait bounds (<code>T: Trait</code>) for
static dispatch (monomorphization) - Use trait objects
(<code>&amp;dyn Trait</code>) for dynamic dispatch (vtable) - Prefer
static dispatch unless you need runtime polymorphism</p>
<p><strong>Pitfalls:</strong> - You can’t implement external traits for
external types (orphan rule) - Trait objects have size restrictions—use
<code>Box&lt;dyn Trait&gt;</code> for ownership - Generic functions are
monomorphized—each instantiation generates code - Error messages point
to trait bounds, not deep in the implementation</p>
<p>Rust’s traits are what C++ concepts try to be, but with explicit
implementation and better error messages.</p>
<hr />
<h1 id="zero-cost-abstractions-for-real">9. Zero-Cost Abstractions (For
Real)</h1>
<blockquote>
<p>C++ promises zero-cost abstractions—but you know the reality. Virtual
functions have vtable overhead, templates bloat binaries, and RAII has
hidden costs. Rust makes the same promise, with different
trade-offs.</p>
</blockquote>
<hr />
<h2 id="why-this-matters-to-a-c-developer-8">Why This Matters to a C++
Developer</h2>
<p>You know that “zero-cost” doesn’t mean “free.” It means you don’t pay
for what you don’t use, and you couldn’t hand-write faster code.</p>
<p>In C++, this works most of the time: - Inline functions have no call
overhead - Templates generate specialized code - RAII destructors are
deterministic - Move semantics avoid copies</p>
<p>But there are costs: - Virtual functions require vtable lookups -
Templates increase binary size - Exception handling adds overhead (even
when not thrown) - Shared pointers have atomic reference counting</p>
<p>You accept these costs because the alternatives are worse. Manual
memory management is error-prone. Writing specialized code for every
type is unmaintainable. Avoiding abstractions makes code fragile.</p>
<p>The question isn’t whether abstractions have cost—it’s whether the
cost is predictable and acceptable.</p>
<hr />
<h2 id="the-c-mental-model-8">The C++ Mental Model</h2>
<p>In C++, zero-cost abstractions are <strong>mostly true, with
exceptions</strong>.</p>
<p><strong>Inlining eliminates overhead.</strong><br />
Small functions are inlined. The abstraction disappears at compile time.
You write readable code, and the compiler generates efficient machine
code.</p>
<div class="sourceCode" id="cb76"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb76-1"><a href="#cb76-1" aria-hidden="true" tabindex="-1"></a><span class="kw">inline</span> <span class="dt">int</span> square<span class="op">(</span><span class="dt">int</span> x<span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> x <span class="op">*</span> x<span class="op">;</span> <span class="op">}</span></span>
<span id="cb76-2"><a href="#cb76-2" aria-hidden="true" tabindex="-1"></a><span class="co">// Compiles to a single multiply instruction</span></span></code></pre></div>
<p><strong>Templates are compile-time.</strong><br />
Generic code is specialized for each type. No runtime dispatch, no type
erasure. The abstraction is resolved at compile time.</p>
<div class="sourceCode" id="cb77"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb77-1"><a href="#cb77-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb77-2"><a href="#cb77-2" aria-hidden="true" tabindex="-1"></a>T max<span class="op">(</span>T a<span class="op">,</span> T b<span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> a <span class="op">&gt;</span> b <span class="op">?</span> a <span class="op">:</span> b<span class="op">;</span> <span class="op">}</span></span>
<span id="cb77-3"><a href="#cb77-3" aria-hidden="true" tabindex="-1"></a><span class="co">// Generates specialized code for each type</span></span></code></pre></div>
<p><strong>RAII is deterministic.</strong><br />
Destructors run at scope exit. No garbage collection, no unpredictable
pauses. You know exactly when cleanup happens.</p>
<p><strong>Move semantics avoid copies.</strong><br />
You transfer ownership instead of copying. The abstraction (unique_ptr,
vector) is as efficient as manual memory management.</p>
<p>But there are exceptions:</p>
<p><strong>Virtual functions have overhead.</strong><br />
Dynamic dispatch requires a vtable lookup. You pay for polymorphism at
runtime.</p>
<div class="sourceCode" id="cb78"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb78-1"><a href="#cb78-1" aria-hidden="true" tabindex="-1"></a><span class="kw">virtual</span> <span class="dt">void</span> process<span class="op">()</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span>  <span class="co">// Vtable lookup on every call</span></span></code></pre></div>
<p><strong>Exceptions have hidden costs.</strong><br />
Even if you never throw, exception handling adds code size and
complexity. Some codebases disable exceptions entirely.</p>
<p><strong>Shared pointers have overhead.</strong><br />
Atomic operations are more expensive than non-atomic operations. If
you’re copying <code>shared_ptr</code> in a tight loop, you’re paying
for synchronization on every copy—this can become a bottleneck in highly
concurrent scenarios.</p>
<p>This model works because: - Most abstractions are zero-cost - The
costs that exist are predictable - You can opt out when performance
matters</p>
<hr />
<h2 id="where-the-model-breaks-down-8">Where the Model Breaks Down</h2>
<p>The problem is that <strong>the costs are not always
obvious</strong>.</p>
<p><strong>Binary bloat from templates.</strong><br />
Every template instantiation generates new code. If you instantiate
<code>std::vector</code> with 20 types, you get 20 copies of the vector
implementation. This increases binary size and compile time.</p>
<p><strong>Inline functions aren’t always inlined.</strong><br />
The compiler decides. If a function is too large, or called through a
pointer, it won’t be inlined. You don’t know until you check the
assembly.</p>
<p><strong>Exception overhead is always present.</strong><br />
Even if you never throw, the compiler generates unwinding tables and
exception-handling code. This adds to binary size and can affect
optimization.</p>
<p><strong>Virtual functions prevent optimization.</strong><br />
The compiler can’t inline through a virtual call. It can’t devirtualize
unless it can prove the exact type. Dynamic dispatch limits what the
optimizer can do.</p>
<p><strong>Shared pointers have hidden costs.</strong><br />
Atomic operations are expensive. If you’re copying
<code>shared_ptr</code> in a tight loop, you’re paying for
synchronization on every copy.</p>
<p><strong>Move semantics aren’t free.</strong><br />
Moving is cheaper than copying, but it’s not free. A moved-from object
is in a valid-but-unspecified state. You still have to check, you still
have to handle it.</p>
<p>Rust makes the same zero-cost promise, but with different trade-offs:
- No virtual functions (use trait objects, which are explicit) - No
exceptions (use <code>Result</code>, which is explicit) - No shared
pointers by default (use <code>Rc</code> or <code>Arc</code>, which are
explicit) - Ownership prevents hidden copies</p>
<p>The costs in Rust are more visible. When you pay for something, you
know it. When you don’t pay, the compiler guarantees it.</p>
<hr />
<h2 id="rusts-model-8">Rust’s Model</h2>
<p>Rust makes the same zero-cost promise as C++, but with different
trade-offs. The costs are more visible, and the compiler provides
stronger guarantees.</p>
<p><strong>Monomorphization for generics.</strong><br />
Generic functions are specialized for each type, just like C++
templates:</p>
<div class="sourceCode" id="cb79"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb79-1"><a href="#cb79-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> max<span class="op">&lt;</span>T<span class="op">:</span> <span class="bu">PartialOrd</span><span class="op">&gt;</span>(a<span class="op">:</span> T<span class="op">,</span> b<span class="op">:</span> T) <span class="op">-&gt;</span> T <span class="op">{</span></span>
<span id="cb79-2"><a href="#cb79-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> a <span class="op">&gt;</span> b <span class="op">{</span> a <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span> b <span class="op">}</span></span>
<span id="cb79-3"><a href="#cb79-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb79-4"><a href="#cb79-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-5"><a href="#cb79-5" aria-hidden="true" tabindex="-1"></a><span class="co">// Generates specialized code for each type:</span></span>
<span id="cb79-6"><a href="#cb79-6" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> x <span class="op">=</span> max(<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span>)<span class="op">;</span>        <span class="co">// max::&lt;i32&gt;</span></span>
<span id="cb79-7"><a href="#cb79-7" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> y <span class="op">=</span> max(<span class="dv">1.0</span><span class="op">,</span> <span class="dv">2.0</span>)<span class="op">;</span>    <span class="co">// max::&lt;f64&gt;</span></span></code></pre></div>
<p>No runtime dispatch. The abstraction disappears at compile time.</p>
<p><strong>Trait objects for dynamic dispatch.</strong><br />
When you need polymorphism, use trait objects. The cost is explicit in
the type:</p>
<div class="sourceCode" id="cb80"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb80-1"><a href="#cb80-1" aria-hidden="true" tabindex="-1"></a><span class="kw">trait</span> Draw <span class="op">{</span></span>
<span id="cb80-2"><a href="#cb80-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> draw(<span class="op">&amp;</span><span class="kw">self</span>)<span class="op">;</span></span>
<span id="cb80-3"><a href="#cb80-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb80-4"><a href="#cb80-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb80-5"><a href="#cb80-5" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Circle <span class="op">{</span> radius<span class="op">:</span> <span class="dt">f64</span> <span class="op">}</span></span>
<span id="cb80-6"><a href="#cb80-6" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Square <span class="op">{</span> side<span class="op">:</span> <span class="dt">f64</span> <span class="op">}</span></span>
<span id="cb80-7"><a href="#cb80-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb80-8"><a href="#cb80-8" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span> Draw <span class="cf">for</span> Circle <span class="op">{</span></span>
<span id="cb80-9"><a href="#cb80-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> draw(<span class="op">&amp;</span><span class="kw">self</span>) <span class="op">{</span> <span class="pp">println!</span>(<span class="st">&quot;Drawing circle&quot;</span>)<span class="op">;</span> <span class="op">}</span></span>
<span id="cb80-10"><a href="#cb80-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb80-11"><a href="#cb80-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb80-12"><a href="#cb80-12" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span> Draw <span class="cf">for</span> Square <span class="op">{</span></span>
<span id="cb80-13"><a href="#cb80-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> draw(<span class="op">&amp;</span><span class="kw">self</span>) <span class="op">{</span> <span class="pp">println!</span>(<span class="st">&quot;Drawing square&quot;</span>)<span class="op">;</span> <span class="op">}</span></span>
<span id="cb80-14"><a href="#cb80-14" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb80-15"><a href="#cb80-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb80-16"><a href="#cb80-16" aria-hidden="true" tabindex="-1"></a><span class="co">// Static dispatch (monomorphization):</span></span>
<span id="cb80-17"><a href="#cb80-17" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> draw_static<span class="op">&lt;</span>T<span class="op">:</span> Draw<span class="op">&gt;</span>(shape<span class="op">:</span> <span class="op">&amp;</span>T) <span class="op">{</span></span>
<span id="cb80-18"><a href="#cb80-18" aria-hidden="true" tabindex="-1"></a>    shape<span class="op">.</span>draw()<span class="op">;</span>  <span class="co">// No vtable lookup</span></span>
<span id="cb80-19"><a href="#cb80-19" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb80-20"><a href="#cb80-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb80-21"><a href="#cb80-21" aria-hidden="true" tabindex="-1"></a><span class="co">// Dynamic dispatch (trait object):</span></span>
<span id="cb80-22"><a href="#cb80-22" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> draw_dynamic(shape<span class="op">:</span> <span class="op">&amp;</span><span class="kw">dyn</span> Draw) <span class="op">{</span></span>
<span id="cb80-23"><a href="#cb80-23" aria-hidden="true" tabindex="-1"></a>    shape<span class="op">.</span>draw()<span class="op">;</span>  <span class="co">// Vtable lookup</span></span>
<span id="cb80-24"><a href="#cb80-24" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Static dispatch is zero-cost. Dynamic dispatch has vtable overhead,
but it’s explicit in the signature.</p>
<p><strong>Iterators are zero-cost.</strong><br />
Rust iterators compile to the same code as hand-written loops:</p>
<div class="sourceCode" id="cb81"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb81-1"><a href="#cb81-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> numbers <span class="op">=</span> <span class="pp">vec!</span>[<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">5</span>]<span class="op">;</span></span>
<span id="cb81-2"><a href="#cb81-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb81-3"><a href="#cb81-3" aria-hidden="true" tabindex="-1"></a><span class="co">// High-level iterator chain:</span></span>
<span id="cb81-4"><a href="#cb81-4" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> sum<span class="op">:</span> <span class="dt">i32</span> <span class="op">=</span> numbers<span class="op">.</span>iter()</span>
<span id="cb81-5"><a href="#cb81-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>filter(<span class="op">|&amp;&amp;</span>x<span class="op">|</span> x <span class="op">%</span> <span class="dv">2</span> <span class="op">==</span> <span class="dv">0</span>)</span>
<span id="cb81-6"><a href="#cb81-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>map(<span class="op">|&amp;</span>x<span class="op">|</span> x <span class="op">*</span> <span class="dv">2</span>)</span>
<span id="cb81-7"><a href="#cb81-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>sum()<span class="op">;</span></span>
<span id="cb81-8"><a href="#cb81-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb81-9"><a href="#cb81-9" aria-hidden="true" tabindex="-1"></a><span class="co">// With optimizations enabled, this typically compiles to code</span></span>
<span id="cb81-10"><a href="#cb81-10" aria-hidden="true" tabindex="-1"></a><span class="co">// as efficient as a hand-written loop. You can verify this by</span></span>
<span id="cb81-11"><a href="#cb81-11" aria-hidden="true" tabindex="-1"></a><span class="co">// checking the assembly output.</span></span></code></pre></div>
<p><strong>No hidden allocations.</strong><br />
Rust doesn’t allocate unless you explicitly use heap types:</p>
<div class="sourceCode" id="cb82"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb82-1"><a href="#cb82-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Stack-allocated:</span></span>
<span id="cb82-2"><a href="#cb82-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> array <span class="op">=</span> [<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">5</span>]<span class="op">;</span></span>
<span id="cb82-3"><a href="#cb82-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-4"><a href="#cb82-4" aria-hidden="true" tabindex="-1"></a><span class="co">// Heap-allocated (explicit):</span></span>
<span id="cb82-5"><a href="#cb82-5" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> vec <span class="op">=</span> <span class="pp">vec!</span>[<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">5</span>]<span class="op">;</span></span>
<span id="cb82-6"><a href="#cb82-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-7"><a href="#cb82-7" aria-hidden="true" tabindex="-1"></a><span class="co">// No hidden copies:</span></span>
<span id="cb82-8"><a href="#cb82-8" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> process(data<span class="op">:</span> <span class="dt">Vec</span><span class="op">&lt;</span><span class="dt">i32</span><span class="op">&gt;</span>) <span class="op">{</span></span>
<span id="cb82-9"><a href="#cb82-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Takes ownership, no copy</span></span>
<span id="cb82-10"><a href="#cb82-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Unlike C++ <code>std::vector</code>, Rust’s <code>Vec</code> doesn’t
copy on assignment—it moves. Copies are explicit with
<code>.clone()</code>.</p>
<p><strong>Inline and const evaluation.</strong><br />
Small functions are inlined, and const functions are evaluated at
compile time:</p>
<div class="sourceCode" id="cb83"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb83-1"><a href="#cb83-1" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>inline<span class="at">]</span></span>
<span id="cb83-2"><a href="#cb83-2" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> square(x<span class="op">:</span> <span class="dt">i32</span>) <span class="op">-&gt;</span> <span class="dt">i32</span> <span class="op">{</span></span>
<span id="cb83-3"><a href="#cb83-3" aria-hidden="true" tabindex="-1"></a>    x <span class="op">*</span> x</span>
<span id="cb83-4"><a href="#cb83-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb83-5"><a href="#cb83-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb83-6"><a href="#cb83-6" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> <span class="kw">fn</span> factorial(n<span class="op">:</span> <span class="dt">u32</span>) <span class="op">-&gt;</span> <span class="dt">u32</span> <span class="op">{</span></span>
<span id="cb83-7"><a href="#cb83-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">match</span> n <span class="op">{</span></span>
<span id="cb83-8"><a href="#cb83-8" aria-hidden="true" tabindex="-1"></a>        <span class="dv">0</span> <span class="op">=&gt;</span> <span class="dv">1</span><span class="op">,</span></span>
<span id="cb83-9"><a href="#cb83-9" aria-hidden="true" tabindex="-1"></a>        _ <span class="op">=&gt;</span> n <span class="op">*</span> factorial(n <span class="op">-</span> <span class="dv">1</span>)<span class="op">,</span></span>
<span id="cb83-10"><a href="#cb83-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb83-11"><a href="#cb83-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb83-12"><a href="#cb83-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb83-13"><a href="#cb83-13" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> FACT_5<span class="op">:</span> <span class="dt">u32</span> <span class="op">=</span> factorial(<span class="dv">5</span>)<span class="op">;</span>  <span class="co">// Computed at compile time</span></span></code></pre></div>
<p><strong>No exceptions overhead.</strong><br />
Rust doesn’t have exceptions. No unwinding tables, no hidden code size
cost. Error handling with <code>Result</code> is explicit and zero-cost
(when inlined).</p>
<p><strong>Reference counting is explicit.</strong><br />
Shared ownership requires <code>Rc</code> or <code>Arc</code>. The cost
is visible in the type:</p>
<div class="sourceCode" id="cb84"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb84-1"><a href="#cb84-1" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">std::rc::</span>Rc<span class="op">;</span></span>
<span id="cb84-2"><a href="#cb84-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-3"><a href="#cb84-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> data <span class="op">=</span> <span class="pp">Rc::</span>new(<span class="pp">vec!</span>[<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span>])<span class="op">;</span></span>
<span id="cb84-4"><a href="#cb84-4" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> data2 <span class="op">=</span> <span class="pp">Rc::</span>clone(<span class="op">&amp;</span>data)<span class="op">;</span>  <span class="co">// Explicit reference count increment</span></span></code></pre></div>
<p>Unlike C++ <code>shared_ptr</code>, you can’t accidentally create
shared ownership. You have to explicitly use <code>Rc</code> or
<code>Arc</code>.</p>
<hr />
<h2 id="takeaways-for-c-developers-8">Takeaways for C++ Developers</h2>
<p><strong>Mental model shift:</strong> - Generics are
monomorphized—zero-cost, but increases binary size - Trait objects are
explicit dynamic dispatch—cost is visible in the type - Iterators are
zero-cost abstractions—compile to tight loops - No hidden allocations or
copies—everything is explicit</p>
<p><strong>Rules of thumb:</strong> - Use generics
(<code>T: Trait</code>) for static dispatch (zero-cost) - Use trait
objects (<code>&amp;dyn Trait</code>) for dynamic dispatch (vtable cost)
- Iterators are as fast as hand-written loops—use them -
<code>Rc</code>/<code>Arc</code> are explicit reference counting—use
only when needed</p>
<p><strong>Pitfalls:</strong> - Monomorphization increases binary
size—each instantiation generates code - Trait objects can’t be
sized—use <code>Box&lt;dyn Trait&gt;</code> or
<code>&amp;dyn Trait</code> - <code>Rc</code> is not thread-safe—use
<code>Arc</code> for concurrent access - Cloning is explicit—no hidden
copies like C++ copy constructors</p>
<p>Rust’s zero-cost abstractions are more explicit than C++. When you
pay for something, you know it. When you don’t, the compiler guarantees
it.</p>
<hr />
<h1 id="unsafe-rust-for-c-veterans">10. Unsafe Rust for C++
Veterans</h1>
<blockquote>
<p>In C++, everything is unsafe by default—you opt into safety with
smart pointers and RAII. In Rust, everything is safe by default—you opt
out with <code>unsafe</code> blocks. The boundary is explicit, and that
changes everything.</p>
</blockquote>
<hr />
<h2 id="why-this-matters-to-a-c-developer-9">Why This Matters to a C++
Developer</h2>
<p>You’re used to having complete control. You can cast away
<code>const</code>, reinterpret memory, dereference raw pointers, and
call functions through function pointers. The compiler trusts you to
know what you’re doing.</p>
<p>This is necessary for: - Interfacing with C libraries - Implementing
low-level data structures - Optimizing performance-critical code -
Working with hardware or memory-mapped I/O</p>
<p>You handle this through: - Discipline (“Be careful with raw
pointers”) - Code review (“Did you check for null?”) - Sanitizers
(AddressSanitizer, UndefinedBehaviorSanitizer) - Testing (and hoping you
hit the edge cases)</p>
<p>The problem is that unsafe code looks like safe code. A raw pointer
dereference looks the same whether it’s guaranteed safe or potentially
undefined behavior. The compiler doesn’t distinguish. You have to.</p>
<hr />
<h2 id="the-c-mental-model-9">The C++ Mental Model</h2>
<p>In C++, <strong>everything is unsafe by default</strong>. Safety is
opt-in.</p>
<p><strong>Raw pointers are everywhere.</strong><br />
You use them for non-owning references, for C interop, for performance.
The compiler doesn’t track whether they’re valid.</p>
<div class="sourceCode" id="cb85"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb85-1"><a href="#cb85-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span><span class="op">*</span> ptr <span class="op">=</span> get_pointer<span class="op">();</span></span>
<span id="cb85-2"><a href="#cb85-2" aria-hidden="true" tabindex="-1"></a><span class="op">*</span>ptr <span class="op">=</span> <span class="dv">42</span><span class="op">;</span>  <span class="co">// Is ptr valid? Is it null? Unknown.</span></span></code></pre></div>
<p><strong>Casts are unchecked.</strong><br />
You can cast between pointer types, cast away <code>const</code>, or
reinterpret memory. The compiler assumes you know what you’re doing.</p>
<div class="sourceCode" id="cb86"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb86-1"><a href="#cb86-1" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="dt">int</span><span class="op">*</span> p <span class="op">=</span> <span class="op">&amp;</span>value<span class="op">;</span></span>
<span id="cb86-2"><a href="#cb86-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span><span class="op">*</span> q <span class="op">=</span> <span class="kw">const_cast</span><span class="op">&lt;</span><span class="dt">int</span><span class="op">*&gt;(</span>p<span class="op">);</span>  <span class="co">// Removes const. Your responsibility.</span></span>
<span id="cb86-3"><a href="#cb86-3" aria-hidden="true" tabindex="-1"></a><span class="op">*</span>q <span class="op">=</span> <span class="dv">42</span><span class="op">;</span>  <span class="co">// Undefined behavior if value was actually const.</span></span></code></pre></div>
<p><strong>Undefined behavior is silent.</strong><br />
If you violate the rules (null dereference, out-of-bounds access, data
race), the compiler doesn’t stop you. You get undefined behavior, which
might work, might crash, or might corrupt memory.</p>
<div class="sourceCode" id="cb87"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb87-1"><a href="#cb87-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> arr<span class="op">[</span><span class="dv">3</span><span class="op">]</span> <span class="op">=</span> <span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">};</span></span>
<span id="cb87-2"><a href="#cb87-2" aria-hidden="true" tabindex="-1"></a>arr<span class="op">[</span><span class="dv">10</span><span class="op">]</span> <span class="op">=</span> <span class="dv">42</span><span class="op">;</span>  <span class="co">// Out of bounds. Undefined behavior. Compiles.</span></span></code></pre></div>
<p><strong>Safety is a discipline.</strong><br />
You use smart pointers, RAII, and const-correctness to make your code
safer. But nothing enforces this. You can always drop down to raw
pointers and manual management.</p>
<p><strong>The boundary is invisible.</strong><br />
There’s no marker that says “this code is unsafe.” You have to read the
code and understand the invariants.</p>
<p>This model works because: - You have complete control - You can
optimize without restrictions - You can interface with any C library</p>
<hr />
<h2 id="where-the-model-breaks-down-9">Where the Model Breaks Down</h2>
<p>The problem is that <strong>unsafe code is indistinguishable from
safe code</strong>.</p>
<p><strong>You can’t audit for safety.</strong><br />
There’s no way to find all the unsafe operations in a codebase. Raw
pointer dereferences, casts, and manual memory management are scattered
throughout. You can’t isolate them.</p>
<p><strong>Refactoring breaks invariants.</strong><br />
You change a function to return a pointer instead of a reference. The
code compiles. But now some callers have dangling pointers. The compiler
doesn’t notice.</p>
<p><strong>Unsafe code infects safe code.</strong><br />
A bug in unsafe code can corrupt memory used by safe code. A data race
in one thread can break invariants in another. The boundary is
porous.</p>
<p><strong>Sanitizers are incomplete.</strong><br />
AddressSanitizer catches many bugs, but not all. It doesn’t catch data
races (that’s ThreadSanitizer). It doesn’t catch logic errors. It only
helps if you run the code path that triggers the bug.</p>
<p><strong>The cost is deferred.</strong><br />
You write the code, it compiles, and you find out later whether it was
safe. By then, the bug is in production, and you’re debugging a crash
with no clear cause.</p>
<p>Rust inverts this. Everything is safe by default. Unsafe operations
require an <code>unsafe</code> block. The compiler enforces memory
safety, thread safety, and lifetime correctness everywhere except inside
<code>unsafe</code> blocks.</p>
<p>This makes the boundary explicit: - You can audit for
<code>unsafe</code> blocks - You can isolate unsafe code and review it
carefully - You can trust that safe code is actually safe</p>
<p>The trade-off is that you have to justify every <code>unsafe</code>
block. You have to document the invariants. You have to prove (to
yourself and reviewers) that the unsafe code upholds Rust’s safety
guarantees.</p>
<p>This is more restrictive than C++. But it’s also more honest: when
you see <code>unsafe</code>, you know to be careful. When you don’t, you
can trust the compiler.</p>
<hr />
<h2 id="rusts-model-9">Rust’s Model</h2>
<p>Rust makes the boundary between safe and unsafe code explicit.
Everything is safe by default. Unsafe operations require an
<code>unsafe</code> block.</p>
<p><strong>Unsafe is explicit.</strong><br />
Five operations require <code>unsafe</code>:</p>
<ol type="1">
<li>Dereferencing raw pointers</li>
<li>Calling unsafe functions</li>
<li>Accessing or modifying mutable static variables</li>
<li>Implementing unsafe traits</li>
<li>Accessing fields of unions</li>
</ol>
<div class="sourceCode" id="cb88"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb88-1"><a href="#cb88-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> read_raw_pointer(ptr<span class="op">:</span> <span class="op">*</span><span class="kw">const</span> <span class="dt">i32</span>) <span class="op">-&gt;</span> <span class="dt">i32</span> <span class="op">{</span></span>
<span id="cb88-2"><a href="#cb88-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">unsafe</span> <span class="op">{</span></span>
<span id="cb88-3"><a href="#cb88-3" aria-hidden="true" tabindex="-1"></a>        <span class="op">*</span>ptr  <span class="co">// Dereference requires unsafe</span></span>
<span id="cb88-4"><a href="#cb88-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb88-5"><a href="#cb88-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The <code>unsafe</code> block says: “I’m taking responsibility for
upholding Rust’s safety guarantees here.”</p>
<p><strong>Raw pointers for C interop.</strong><br />
When interfacing with C, you use raw pointers:</p>
<div class="sourceCode" id="cb89"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb89-1"><a href="#cb89-1" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">std::ffi::</span>CString<span class="op">;</span></span>
<span id="cb89-2"><a href="#cb89-2" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">std::os::raw::</span><span class="dt">c_char</span><span class="op">;</span></span>
<span id="cb89-3"><a href="#cb89-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb89-4"><a href="#cb89-4" aria-hidden="true" tabindex="-1"></a><span class="kw">extern</span> <span class="st">&quot;C&quot;</span> <span class="op">{</span></span>
<span id="cb89-5"><a href="#cb89-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> strlen(s<span class="op">:</span> <span class="op">*</span><span class="kw">const</span> <span class="dt">c_char</span>) <span class="op">-&gt;</span> <span class="dt">usize</span><span class="op">;</span></span>
<span id="cb89-6"><a href="#cb89-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb89-7"><a href="#cb89-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb89-8"><a href="#cb89-8" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> get_length(s<span class="op">:</span> <span class="op">&amp;</span><span class="dt">str</span>) <span class="op">-&gt;</span> <span class="dt">usize</span> <span class="op">{</span></span>
<span id="cb89-9"><a href="#cb89-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> c_str <span class="op">=</span> <span class="pp">CString::</span>new(s)<span class="op">.</span>unwrap()<span class="op">;</span></span>
<span id="cb89-10"><a href="#cb89-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">unsafe</span> <span class="op">{</span></span>
<span id="cb89-11"><a href="#cb89-11" aria-hidden="true" tabindex="-1"></a>        strlen(c_str<span class="op">.</span>as_ptr())</span>
<span id="cb89-12"><a href="#cb89-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb89-13"><a href="#cb89-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The <code>unsafe</code> block isolates the C interop. The rest of
your code is safe.</p>
<p><strong>Unsafe functions.</strong><br />
Functions that have safety requirements are marked
<code>unsafe</code>:</p>
<div class="sourceCode" id="cb90"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb90-1"><a href="#cb90-1" aria-hidden="true" tabindex="-1"></a><span class="kw">unsafe</span> <span class="kw">fn</span> write_to_address(addr<span class="op">:</span> <span class="dt">usize</span><span class="op">,</span> value<span class="op">:</span> <span class="dt">i32</span>) <span class="op">{</span></span>
<span id="cb90-2"><a href="#cb90-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> ptr <span class="op">=</span> addr <span class="kw">as</span> <span class="op">*</span><span class="kw">mut</span> <span class="dt">i32</span><span class="op">;</span></span>
<span id="cb90-3"><a href="#cb90-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">*</span>ptr <span class="op">=</span> value<span class="op">;</span></span>
<span id="cb90-4"><a href="#cb90-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb90-5"><a href="#cb90-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb90-6"><a href="#cb90-6" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb90-7"><a href="#cb90-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">mut</span> x <span class="op">=</span> <span class="dv">42</span><span class="op">;</span></span>
<span id="cb90-8"><a href="#cb90-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> addr <span class="op">=</span> <span class="op">&amp;</span><span class="kw">mut</span> x <span class="kw">as</span> <span class="op">*</span><span class="kw">mut</span> <span class="dt">i32</span> <span class="kw">as</span> <span class="dt">usize</span><span class="op">;</span></span>
<span id="cb90-9"><a href="#cb90-9" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb90-10"><a href="#cb90-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">unsafe</span> <span class="op">{</span></span>
<span id="cb90-11"><a href="#cb90-11" aria-hidden="true" tabindex="-1"></a>        write_to_address(addr<span class="op">,</span> <span class="dv">100</span>)<span class="op">;</span></span>
<span id="cb90-12"><a href="#cb90-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb90-13"><a href="#cb90-13" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb90-14"><a href="#cb90-14" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> x)<span class="op">;</span>  <span class="co">// 100</span></span>
<span id="cb90-15"><a href="#cb90-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Calling an <code>unsafe</code> function requires an
<code>unsafe</code> block. This makes the boundary visible.</p>
<p><strong>Safe abstractions over unsafe code.</strong><br />
You can build safe APIs on top of unsafe code:</p>
<div class="sourceCode" id="cb91"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb91-1"><a href="#cb91-1" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">struct</span> Buffer <span class="op">{</span></span>
<span id="cb91-2"><a href="#cb91-2" aria-hidden="true" tabindex="-1"></a>    data<span class="op">:</span> <span class="op">*</span><span class="kw">mut</span> <span class="dt">u8</span><span class="op">,</span></span>
<span id="cb91-3"><a href="#cb91-3" aria-hidden="true" tabindex="-1"></a>    len<span class="op">:</span> <span class="dt">usize</span><span class="op">,</span></span>
<span id="cb91-4"><a href="#cb91-4" aria-hidden="true" tabindex="-1"></a>    capacity<span class="op">:</span> <span class="dt">usize</span><span class="op">,</span></span>
<span id="cb91-5"><a href="#cb91-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb91-6"><a href="#cb91-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb91-7"><a href="#cb91-7" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span> Buffer <span class="op">{</span></span>
<span id="cb91-8"><a href="#cb91-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> <span class="kw">fn</span> new(capacity<span class="op">:</span> <span class="dt">usize</span>) <span class="op">-&gt;</span> <span class="dt">Self</span> <span class="op">{</span></span>
<span id="cb91-9"><a href="#cb91-9" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> layout <span class="op">=</span> <span class="pp">std::alloc::Layout::array::</span><span class="op">&lt;</span><span class="dt">u8</span><span class="op">&gt;</span>(capacity)<span class="op">.</span>unwrap()<span class="op">;</span></span>
<span id="cb91-10"><a href="#cb91-10" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> data <span class="op">=</span> <span class="kw">unsafe</span> <span class="op">{</span></span>
<span id="cb91-11"><a href="#cb91-11" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> ptr <span class="op">=</span> <span class="pp">std::alloc::</span>alloc(layout)<span class="op">;</span></span>
<span id="cb91-12"><a href="#cb91-12" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> ptr<span class="op">.</span>is_null() <span class="op">{</span></span>
<span id="cb91-13"><a href="#cb91-13" aria-hidden="true" tabindex="-1"></a>                <span class="pp">std::alloc::</span>handle_alloc_error(layout)<span class="op">;</span></span>
<span id="cb91-14"><a href="#cb91-14" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb91-15"><a href="#cb91-15" aria-hidden="true" tabindex="-1"></a>            ptr</span>
<span id="cb91-16"><a href="#cb91-16" aria-hidden="true" tabindex="-1"></a>        <span class="op">};</span></span>
<span id="cb91-17"><a href="#cb91-17" aria-hidden="true" tabindex="-1"></a>        Buffer <span class="op">{</span> data<span class="op">,</span> len<span class="op">:</span> <span class="dv">0</span><span class="op">,</span> capacity <span class="op">}</span></span>
<span id="cb91-18"><a href="#cb91-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb91-19"><a href="#cb91-19" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb91-20"><a href="#cb91-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> <span class="kw">fn</span> push(<span class="op">&amp;</span><span class="kw">mut</span> <span class="kw">self</span><span class="op">,</span> byte<span class="op">:</span> <span class="dt">u8</span>) <span class="op">{</span></span>
<span id="cb91-21"><a href="#cb91-21" aria-hidden="true" tabindex="-1"></a>        <span class="pp">assert!</span>(<span class="kw">self</span><span class="op">.</span>len <span class="op">&lt;</span> <span class="kw">self</span><span class="op">.</span>capacity<span class="op">,</span> <span class="st">&quot;Buffer full&quot;</span>)<span class="op">;</span></span>
<span id="cb91-22"><a href="#cb91-22" aria-hidden="true" tabindex="-1"></a>        <span class="kw">unsafe</span> <span class="op">{</span></span>
<span id="cb91-23"><a href="#cb91-23" aria-hidden="true" tabindex="-1"></a>            <span class="op">*</span><span class="kw">self</span><span class="op">.</span>data<span class="op">.</span>add(<span class="kw">self</span><span class="op">.</span>len) <span class="op">=</span> byte<span class="op">;</span></span>
<span id="cb91-24"><a href="#cb91-24" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb91-25"><a href="#cb91-25" aria-hidden="true" tabindex="-1"></a>        <span class="kw">self</span><span class="op">.</span>len <span class="op">+=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb91-26"><a href="#cb91-26" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb91-27"><a href="#cb91-27" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb91-28"><a href="#cb91-28" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> <span class="kw">fn</span> get(<span class="op">&amp;</span><span class="kw">self</span><span class="op">,</span> index<span class="op">:</span> <span class="dt">usize</span>) <span class="op">-&gt;</span> <span class="dt">Option</span><span class="op">&lt;</span><span class="dt">u8</span><span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb91-29"><a href="#cb91-29" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> index <span class="op">&lt;</span> <span class="kw">self</span><span class="op">.</span>len <span class="op">{</span></span>
<span id="cb91-30"><a href="#cb91-30" aria-hidden="true" tabindex="-1"></a>            <span class="cn">Some</span>(<span class="kw">unsafe</span> <span class="op">{</span> <span class="op">*</span><span class="kw">self</span><span class="op">.</span>data<span class="op">.</span>add(index) <span class="op">}</span>)</span>
<span id="cb91-31"><a href="#cb91-31" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb91-32"><a href="#cb91-32" aria-hidden="true" tabindex="-1"></a>            <span class="cn">None</span></span>
<span id="cb91-33"><a href="#cb91-33" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb91-34"><a href="#cb91-34" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb91-35"><a href="#cb91-35" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb91-36"><a href="#cb91-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb91-37"><a href="#cb91-37" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span> <span class="bu">Drop</span> <span class="cf">for</span> Buffer <span class="op">{</span></span>
<span id="cb91-38"><a href="#cb91-38" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> drop(<span class="op">&amp;</span><span class="kw">mut</span> <span class="kw">self</span>) <span class="op">{</span></span>
<span id="cb91-39"><a href="#cb91-39" aria-hidden="true" tabindex="-1"></a>        <span class="kw">unsafe</span> <span class="op">{</span></span>
<span id="cb91-40"><a href="#cb91-40" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> layout <span class="op">=</span> <span class="pp">std::alloc::Layout::array::</span><span class="op">&lt;</span><span class="dt">u8</span><span class="op">&gt;</span>(<span class="kw">self</span><span class="op">.</span>capacity)<span class="op">.</span>unwrap()<span class="op">;</span></span>
<span id="cb91-41"><a href="#cb91-41" aria-hidden="true" tabindex="-1"></a>            <span class="pp">std::alloc::</span>dealloc(<span class="kw">self</span><span class="op">.</span>data<span class="op">,</span> layout)<span class="op">;</span></span>
<span id="cb91-42"><a href="#cb91-42" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb91-43"><a href="#cb91-43" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb91-44"><a href="#cb91-44" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb91-45"><a href="#cb91-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb91-46"><a href="#cb91-46" aria-hidden="true" tabindex="-1"></a><span class="co">// Safety: Buffer is not Send/Sync by default due to raw pointer.</span></span>
<span id="cb91-47"><a href="#cb91-47" aria-hidden="true" tabindex="-1"></a><span class="co">// In production, you&#39;d need to carefully implement these if needed.</span></span></code></pre></div>
<p>The <code>Buffer</code> API is safe—users can’t violate memory
safety. The <code>unsafe</code> blocks are isolated and auditable.</p>
<p><strong>Unsafe traits.</strong><br />
Some traits have safety requirements:</p>
<div class="sourceCode" id="cb92"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb92-1"><a href="#cb92-1" aria-hidden="true" tabindex="-1"></a><span class="kw">unsafe</span> <span class="kw">trait</span> Zeroable <span class="op">{</span></span>
<span id="cb92-2"><a href="#cb92-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Safe to fill with zeros</span></span>
<span id="cb92-3"><a href="#cb92-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Safety: Only implement for types where all-zeros is a valid bit pattern</span></span>
<span id="cb92-4"><a href="#cb92-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb92-5"><a href="#cb92-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb92-6"><a href="#cb92-6" aria-hidden="true" tabindex="-1"></a><span class="kw">unsafe</span> <span class="kw">impl</span> Zeroable <span class="cf">for</span> <span class="dt">u32</span> <span class="op">{}</span>  <span class="co">// 0 is a valid u32</span></span>
<span id="cb92-7"><a href="#cb92-7" aria-hidden="true" tabindex="-1"></a><span class="kw">unsafe</span> <span class="kw">impl</span> Zeroable <span class="cf">for</span> <span class="dt">i32</span> <span class="op">{}</span>  <span class="co">// 0 is a valid i32</span></span>
<span id="cb92-8"><a href="#cb92-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb92-9"><a href="#cb92-9" aria-hidden="true" tabindex="-1"></a><span class="co">// NOT safe for: bool (only 0 and 1 are valid), references, etc.</span></span>
<span id="cb92-10"><a href="#cb92-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb92-11"><a href="#cb92-11" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> zero_out<span class="op">&lt;</span>T<span class="op">:</span> Zeroable<span class="op">&gt;</span>(value<span class="op">:</span> <span class="op">&amp;</span><span class="kw">mut</span> T) <span class="op">{</span></span>
<span id="cb92-12"><a href="#cb92-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">unsafe</span> <span class="op">{</span></span>
<span id="cb92-13"><a href="#cb92-13" aria-hidden="true" tabindex="-1"></a>        <span class="pp">std::ptr::</span>write_bytes(value <span class="kw">as</span> <span class="op">*</span><span class="kw">mut</span> T<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">1</span>)<span class="op">;</span></span>
<span id="cb92-14"><a href="#cb92-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb92-15"><a href="#cb92-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Implementing an <code>unsafe</code> trait requires
<code>unsafe impl</code>. This documents that you’re upholding the
trait’s safety contract.</p>
<p><strong>Auditing for unsafe.</strong><br />
You can search for <code>unsafe</code> to find all potentially dangerous
code:</p>
<div class="sourceCode" id="cb93"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb93-1"><a href="#cb93-1" aria-hidden="true" tabindex="-1"></a><span class="fu">grep</span> <span class="at">-r</span> <span class="st">&quot;unsafe&quot;</span> src/</span></code></pre></div>
<p>This is impossible in C++—unsafe code looks like safe code.</p>
<hr />
<h2 id="takeaways-for-c-developers-9">Takeaways for C++ Developers</h2>
<p><strong>Mental model shift:</strong> - Safe by default, unsafe by
opt-in (opposite of C++) - <code>unsafe</code> blocks are explicit
boundaries—you can audit them - Unsafe code must uphold Rust’s safety
guarantees - Safe abstractions can be built on unsafe foundations</p>
<p><strong>Rules of thumb:</strong> - Use <code>unsafe</code> only when
necessary (C interop, performance, low-level code) - Keep
<code>unsafe</code> blocks small and well-documented - Build safe APIs
on top of unsafe code - Document the safety invariants you’re
upholding</p>
<p><strong>Pitfalls:</strong> - <code>unsafe</code> doesn’t disable the
borrow checker—it just allows specific operations - You’re responsible
for upholding safety guarantees in <code>unsafe</code> blocks - Unsafe
code can break safe code if invariants are violated - Raw pointers don’t
track lifetimes—you must ensure validity manually</p>
<p>Rust’s <code>unsafe</code> is what C++ does everywhere, but isolated
and auditable. The boundary is explicit, not invisible.</p>
<hr />
<h1 id="concurrency-without-data-races">11. Concurrency Without Data
Races</h1>
<blockquote>
<p>In C++, you use mutexes, atomics, and discipline to avoid data races.
Rust makes data races a compile error—not through runtime checks, but
through the type system.</p>
</blockquote>
<hr />
<h2 id="why-this-matters-to-a-c-developer-10">Why This Matters to a C++
Developer</h2>
<p>You know how to write concurrent code. You use mutexes to protect
shared state, atomics for lock-free operations, and thread-local storage
to avoid sharing. You understand race conditions, deadlocks, and memory
ordering.</p>
<p>This works through: - Locking discipline (“Always lock before
accessing shared data”) - Code review (“Did you forget to lock?”) -
Thread sanitizers (ThreadSanitizer catches many races) - Testing (and
hoping you hit the race condition)</p>
<p>The problem is that the compiler doesn’t help. It doesn’t know which
data is shared, which locks protect which data, or whether you’ve locked
correctly. You have to get it right every time.</p>
<p>When you don’t: - Data races cause undefined behavior - Deadlocks
hang your program - Race conditions produce incorrect results - Bugs
only appear under load, in production</p>
<p>These bugs are the hardest to debug. They’re non-deterministic, hard
to reproduce, and often disappear when you add logging or run under a
debugger.</p>
<hr />
<h2 id="the-c-mental-model-10">The C++ Mental Model</h2>
<p>In C++, concurrency is <strong>manual and unchecked</strong>.</p>
<p><strong>Shared state is implicit.</strong><br />
Any data accessible from multiple threads is potentially shared. The
compiler doesn’t track this. You have to know which data is shared and
protect it.</p>
<div class="sourceCode" id="cb94"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb94-1"><a href="#cb94-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> counter <span class="op">=</span> <span class="dv">0</span><span class="op">;</span>  <span class="co">// Shared between threads? Maybe.</span></span>
<span id="cb94-2"><a href="#cb94-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb94-3"><a href="#cb94-3" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> increment<span class="op">()</span> <span class="op">{</span></span>
<span id="cb94-4"><a href="#cb94-4" aria-hidden="true" tabindex="-1"></a>    counter<span class="op">++;</span>  <span class="co">// Data race if called from multiple threads</span></span>
<span id="cb94-5"><a href="#cb94-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><strong>Locking is a discipline.</strong><br />
You use mutexes to protect shared data. But nothing enforces that you
lock before accessing. You just have to remember.</p>
<div class="sourceCode" id="cb95"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb95-1"><a href="#cb95-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>mutex mtx<span class="op">;</span></span>
<span id="cb95-2"><a href="#cb95-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> shared_data <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb95-3"><a href="#cb95-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb95-4"><a href="#cb95-4" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> update<span class="op">()</span> <span class="op">{</span></span>
<span id="cb95-5"><a href="#cb95-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Forgot to lock! Data race.</span></span>
<span id="cb95-6"><a href="#cb95-6" aria-hidden="true" tabindex="-1"></a>    shared_data<span class="op">++;</span></span>
<span id="cb95-7"><a href="#cb95-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><strong>Atomics are opt-in.</strong><br />
If you need lock-free access, you use <code>std::atomic</code>. But
nothing stops you from accessing the same data both atomically and
non-atomically, which is undefined behavior.</p>
<div class="sourceCode" id="cb96"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb96-1"><a href="#cb96-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>atomic<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> counter <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb96-2"><a href="#cb96-2" aria-hidden="true" tabindex="-1"></a>counter<span class="op">++;</span>  <span class="co">// Atomic</span></span>
<span id="cb96-3"><a href="#cb96-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span><span class="op">*</span> ptr <span class="op">=</span> <span class="op">&amp;</span>counter<span class="op">;</span></span>
<span id="cb96-4"><a href="#cb96-4" aria-hidden="true" tabindex="-1"></a><span class="op">(*</span>ptr<span class="op">)++;</span>  <span class="co">// Non-atomic access to atomic variable. Undefined behavior.</span></span></code></pre></div>
<p><strong>Send and Sync are implicit.</strong><br />
Some types are safe to send between threads (<code>std::string</code>),
some aren’t (like <code>std::unique_ptr</code> to a non-thread-safe
type). The compiler doesn’t enforce this—you have to know.</p>
<p><strong>Data races are undefined behavior.</strong><br />
If two threads access the same memory, and at least one is writing, and
there’s no synchronization, you have a data race. The compiler doesn’t
prevent this. The behavior is undefined.</p>
<p>This model works when: - You’re disciplined about locking - Code
review catches mistakes - ThreadSanitizer finds races in testing</p>
<hr />
<h2 id="where-the-model-breaks-down-10">Where the Model Breaks Down</h2>
<p>The problem is that <strong>the compiler can’t verify your locking
discipline</strong>.</p>
<p><strong>Forgotten locks.</strong><br />
You add a new function that accesses shared data. You forget to lock.
The code compiles. You have a data race.</p>
<div class="sourceCode" id="cb97"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb97-1"><a href="#cb97-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>mutex mtx<span class="op">;</span></span>
<span id="cb97-2"><a href="#cb97-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> shared_data <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb97-3"><a href="#cb97-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb97-4"><a href="#cb97-4" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> update<span class="op">()</span> <span class="op">{</span></span>
<span id="cb97-5"><a href="#cb97-5" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>lock_guard<span class="op">&lt;</span><span class="bu">std::</span>mutex<span class="op">&gt;</span> lock<span class="op">(</span>mtx<span class="op">);</span></span>
<span id="cb97-6"><a href="#cb97-6" aria-hidden="true" tabindex="-1"></a>    shared_data<span class="op">++;</span></span>
<span id="cb97-7"><a href="#cb97-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb97-8"><a href="#cb97-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb97-9"><a href="#cb97-9" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> read<span class="op">()</span> <span class="op">{</span></span>
<span id="cb97-10"><a href="#cb97-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> shared_data<span class="op">;</span>  <span class="co">// Forgot to lock! Data race.</span></span>
<span id="cb97-11"><a href="#cb97-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><strong>Wrong locks.</strong><br />
You have multiple mutexes. You lock the wrong one. The code compiles.
You have a data race.</p>
<div class="sourceCode" id="cb98"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb98-1"><a href="#cb98-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>mutex mtx1<span class="op">,</span> mtx2<span class="op">;</span></span>
<span id="cb98-2"><a href="#cb98-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> data1 <span class="op">=</span> <span class="dv">0</span><span class="op">,</span> data2 <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb98-3"><a href="#cb98-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb98-4"><a href="#cb98-4" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> update<span class="op">()</span> <span class="op">{</span></span>
<span id="cb98-5"><a href="#cb98-5" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>lock_guard<span class="op">&lt;</span><span class="bu">std::</span>mutex<span class="op">&gt;</span> lock<span class="op">(</span>mtx1<span class="op">);</span></span>
<span id="cb98-6"><a href="#cb98-6" aria-hidden="true" tabindex="-1"></a>    data2<span class="op">++;</span>  <span class="co">// Locked mtx1, but accessing data2. Data race.</span></span>
<span id="cb98-7"><a href="#cb98-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><strong>Shared references.</strong><br />
You pass a reference to shared data to a thread. The thread outlives the
data. The compiler doesn’t stop you. You have a use-after-free.</p>
<div class="sourceCode" id="cb99"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb99-1"><a href="#cb99-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> spawn_thread<span class="op">()</span> <span class="op">{</span></span>
<span id="cb99-2"><a href="#cb99-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> local <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb99-3"><a href="#cb99-3" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>thread t<span class="op">([&amp;]()</span> <span class="op">{</span> local<span class="op">++;</span> <span class="op">});</span>  <span class="co">// Captures reference to local</span></span>
<span id="cb99-4"><a href="#cb99-4" aria-hidden="true" tabindex="-1"></a>    t<span class="op">.</span>detach<span class="op">();</span></span>
<span id="cb99-5"><a href="#cb99-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>  <span class="co">// local destroyed, but thread still running. Use-after-free.</span></span></code></pre></div>
<p><strong>Atomics mixed with non-atomics.</strong><br />
You access an atomic variable non-atomically. The compiler doesn’t stop
you. You have undefined behavior.</p>
<p><strong>The cost is deferred.</strong><br />
You write the code, it compiles, and you find out later whether it was
safe. By then, the bug is in production, and you’re debugging a race
condition that only happens under load.</p>
<p>Rust prevents data races at compile time. The type system tracks
which types can be sent between threads (<code>Send</code>) and which
can be shared between threads (<code>Sync</code>). The borrow checker
ensures you can’t have mutable access to shared data without
synchronization.</p>
<p>This means: - You can’t forget to lock—the compiler enforces it - You
can’t lock the wrong mutex—the type system tracks it - You can’t share
references unsafely—the lifetime checker prevents it</p>
<p>The trade-off is that you have to structure your code to satisfy the
compiler. But once it compiles, data races are impossible (outside
<code>unsafe</code> blocks).</p>
<hr />
<h2 id="rusts-model-10">Rust’s Model</h2>
<p>Rust prevents data races at compile time through the type system. Two
traits—<code>Send</code> and <code>Sync</code>—encode thread safety, and
the borrow checker enforces it.</p>
<p><strong>Send and Sync traits.</strong><br />
- <code>Send</code>: A type can be transferred between threads -
<code>Sync</code>: A type can be shared between threads (via
<code>&amp;T</code>)</p>
<p>Most types are <code>Send</code> and <code>Sync</code> automatically.
The compiler derives them based on the fields.</p>
<div class="sourceCode" id="cb100"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb100-1"><a href="#cb100-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Config <span class="op">{</span></span>
<span id="cb100-2"><a href="#cb100-2" aria-hidden="true" tabindex="-1"></a>    host<span class="op">:</span> <span class="dt">String</span><span class="op">,</span>    <span class="co">// Send + Sync</span></span>
<span id="cb100-3"><a href="#cb100-3" aria-hidden="true" tabindex="-1"></a>    port<span class="op">:</span> <span class="dt">u16</span><span class="op">,</span>       <span class="co">// Send + Sync</span></span>
<span id="cb100-4"><a href="#cb100-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb100-5"><a href="#cb100-5" aria-hidden="true" tabindex="-1"></a><span class="co">// Config is automatically Send + Sync</span></span></code></pre></div>
<p>Types that aren’t thread-safe don’t implement these traits:</p>
<div class="sourceCode" id="cb101"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb101-1"><a href="#cb101-1" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">std::rc::</span>Rc<span class="op">;</span></span>
<span id="cb101-2"><a href="#cb101-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-3"><a href="#cb101-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> data <span class="op">=</span> <span class="pp">Rc::</span>new(<span class="pp">vec!</span>[<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span>])<span class="op">;</span></span>
<span id="cb101-4"><a href="#cb101-4" aria-hidden="true" tabindex="-1"></a><span class="co">// std::thread::spawn(move || {</span></span>
<span id="cb101-5"><a href="#cb101-5" aria-hidden="true" tabindex="-1"></a><span class="co">//     println!(&quot;{:?}&quot;, data);  // Compile error: Rc is not Send</span></span>
<span id="cb101-6"><a href="#cb101-6" aria-hidden="true" tabindex="-1"></a><span class="co">// });</span></span></code></pre></div>
<p><strong>Arc for shared ownership across threads.</strong><br />
Use <code>Arc</code> (atomic reference counting) for shared
ownership:</p>
<div class="sourceCode" id="cb102"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb102-1"><a href="#cb102-1" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">std::sync::</span>Arc<span class="op">;</span></span>
<span id="cb102-2"><a href="#cb102-2" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">std::</span>thread<span class="op">;</span></span>
<span id="cb102-3"><a href="#cb102-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb102-4"><a href="#cb102-4" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> data <span class="op">=</span> <span class="pp">Arc::</span>new(<span class="pp">vec!</span>[<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">5</span>])<span class="op">;</span></span>
<span id="cb102-5"><a href="#cb102-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb102-6"><a href="#cb102-6" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> handles<span class="op">:</span> <span class="dt">Vec</span><span class="op">&lt;</span>_<span class="op">&gt;</span> <span class="op">=</span> (<span class="dv">0</span><span class="op">..</span><span class="dv">3</span>)<span class="op">.</span>map(<span class="op">|</span>i<span class="op">|</span> <span class="op">{</span></span>
<span id="cb102-7"><a href="#cb102-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> data <span class="op">=</span> <span class="pp">Arc::</span>clone(<span class="op">&amp;</span>data)<span class="op">;</span></span>
<span id="cb102-8"><a href="#cb102-8" aria-hidden="true" tabindex="-1"></a>    <span class="pp">thread::</span>spawn(<span class="kw">move</span> <span class="op">||</span> <span class="op">{</span></span>
<span id="cb102-9"><a href="#cb102-9" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;Thread {}: {:?}&quot;</span><span class="op">,</span> i<span class="op">,</span> data)<span class="op">;</span></span>
<span id="cb102-10"><a href="#cb102-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>)</span>
<span id="cb102-11"><a href="#cb102-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>)<span class="op">.</span>collect()<span class="op">;</span></span>
<span id="cb102-12"><a href="#cb102-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb102-13"><a href="#cb102-13" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> handle <span class="kw">in</span> handles <span class="op">{</span></span>
<span id="cb102-14"><a href="#cb102-14" aria-hidden="true" tabindex="-1"></a>    handle<span class="op">.</span>join()<span class="op">.</span>unwrap()<span class="op">;</span></span>
<span id="cb102-15"><a href="#cb102-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><code>Arc</code> is <code>Send</code> and <code>Sync</code>. The
compiler ensures you can’t share non-thread-safe types.</p>
<p><strong>Mutex for shared mutable state.</strong><br />
Use <code>Mutex</code> to protect shared mutable data:</p>
<div class="sourceCode" id="cb103"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb103-1"><a href="#cb103-1" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">std::sync::</span><span class="op">{</span>Arc<span class="op">,</span> Mutex<span class="op">};</span></span>
<span id="cb103-2"><a href="#cb103-2" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">std::</span>thread<span class="op">;</span></span>
<span id="cb103-3"><a href="#cb103-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb103-4"><a href="#cb103-4" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> counter <span class="op">=</span> <span class="pp">Arc::</span>new(<span class="pp">Mutex::</span>new(<span class="dv">0</span>))<span class="op">;</span></span>
<span id="cb103-5"><a href="#cb103-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb103-6"><a href="#cb103-6" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> handles<span class="op">:</span> <span class="dt">Vec</span><span class="op">&lt;</span>_<span class="op">&gt;</span> <span class="op">=</span> (<span class="dv">0</span><span class="op">..</span><span class="dv">10</span>)<span class="op">.</span>map(<span class="op">|</span>_<span class="op">|</span> <span class="op">{</span></span>
<span id="cb103-7"><a href="#cb103-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> counter <span class="op">=</span> <span class="pp">Arc::</span>clone(<span class="op">&amp;</span>counter)<span class="op">;</span></span>
<span id="cb103-8"><a href="#cb103-8" aria-hidden="true" tabindex="-1"></a>    <span class="pp">thread::</span>spawn(<span class="kw">move</span> <span class="op">||</span> <span class="op">{</span></span>
<span id="cb103-9"><a href="#cb103-9" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> <span class="kw">mut</span> num <span class="op">=</span> counter<span class="op">.</span>lock()<span class="op">.</span>unwrap()<span class="op">;</span></span>
<span id="cb103-10"><a href="#cb103-10" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Note: lock() returns Result because the mutex can be &quot;poisoned&quot;</span></span>
<span id="cb103-11"><a href="#cb103-11" aria-hidden="true" tabindex="-1"></a>        <span class="co">// if a thread panicked while holding the lock. unwrap() is</span></span>
<span id="cb103-12"><a href="#cb103-12" aria-hidden="true" tabindex="-1"></a>        <span class="co">// acceptable here because we&#39;re not doing anything that can panic.</span></span>
<span id="cb103-13"><a href="#cb103-13" aria-hidden="true" tabindex="-1"></a>        <span class="op">*</span>num <span class="op">+=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb103-14"><a href="#cb103-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>)</span>
<span id="cb103-15"><a href="#cb103-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>)<span class="op">.</span>collect()<span class="op">;</span></span>
<span id="cb103-16"><a href="#cb103-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb103-17"><a href="#cb103-17" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> handle <span class="kw">in</span> handles <span class="op">{</span></span>
<span id="cb103-18"><a href="#cb103-18" aria-hidden="true" tabindex="-1"></a>    handle<span class="op">.</span>join()<span class="op">.</span>unwrap()<span class="op">;</span></span>
<span id="cb103-19"><a href="#cb103-19" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb103-20"><a href="#cb103-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb103-21"><a href="#cb103-21" aria-hidden="true" tabindex="-1"></a><span class="pp">println!</span>(<span class="st">&quot;Result: {}&quot;</span><span class="op">,</span> <span class="op">*</span>counter<span class="op">.</span>lock()<span class="op">.</span>unwrap())<span class="op">;</span></span></code></pre></div>
<p>The <code>Mutex</code> ensures exclusive access. You can’t access the
data without locking—the type system enforces it.</p>
<p><strong>The borrow checker prevents data races.</strong><br />
You can’t have mutable access to shared data without
synchronization:</p>
<div class="sourceCode" id="cb104"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb104-1"><a href="#cb104-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">mut</span> data <span class="op">=</span> <span class="pp">vec!</span>[<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span>]<span class="op">;</span></span>
<span id="cb104-2"><a href="#cb104-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb104-3"><a href="#cb104-3" aria-hidden="true" tabindex="-1"></a><span class="co">// This won&#39;t compile:</span></span>
<span id="cb104-4"><a href="#cb104-4" aria-hidden="true" tabindex="-1"></a><span class="co">// thread::spawn(|| {</span></span>
<span id="cb104-5"><a href="#cb104-5" aria-hidden="true" tabindex="-1"></a><span class="co">//     data.push(4);  // Error: can&#39;t capture mutable reference</span></span>
<span id="cb104-6"><a href="#cb104-6" aria-hidden="true" tabindex="-1"></a><span class="co">// });</span></span></code></pre></div>
<p>The compiler prevents you from sharing mutable references across
threads.</p>
<p><strong>RwLock for read-heavy workloads.</strong><br />
Use <code>RwLock</code> when you have many readers and few writers:</p>
<div class="sourceCode" id="cb105"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb105-1"><a href="#cb105-1" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">std::sync::</span><span class="op">{</span>Arc<span class="op">,</span> RwLock<span class="op">};</span></span>
<span id="cb105-2"><a href="#cb105-2" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">std::</span>thread<span class="op">;</span></span>
<span id="cb105-3"><a href="#cb105-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb105-4"><a href="#cb105-4" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> data <span class="op">=</span> <span class="pp">Arc::</span>new(<span class="pp">RwLock::</span>new(<span class="pp">vec!</span>[<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span>]))<span class="op">;</span></span>
<span id="cb105-5"><a href="#cb105-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb105-6"><a href="#cb105-6" aria-hidden="true" tabindex="-1"></a><span class="co">// Multiple readers:</span></span>
<span id="cb105-7"><a href="#cb105-7" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> handles<span class="op">:</span> <span class="dt">Vec</span><span class="op">&lt;</span>_<span class="op">&gt;</span> <span class="op">=</span> (<span class="dv">0</span><span class="op">..</span><span class="dv">5</span>)<span class="op">.</span>map(<span class="op">|</span>i<span class="op">|</span> <span class="op">{</span></span>
<span id="cb105-8"><a href="#cb105-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> data <span class="op">=</span> <span class="pp">Arc::</span>clone(<span class="op">&amp;</span>data)<span class="op">;</span></span>
<span id="cb105-9"><a href="#cb105-9" aria-hidden="true" tabindex="-1"></a>    <span class="pp">thread::</span>spawn(<span class="kw">move</span> <span class="op">||</span> <span class="op">{</span></span>
<span id="cb105-10"><a href="#cb105-10" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> read <span class="op">=</span> data<span class="op">.</span>read()<span class="op">.</span>unwrap()<span class="op">;</span></span>
<span id="cb105-11"><a href="#cb105-11" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;Reader {}: {:?}&quot;</span><span class="op">,</span> i<span class="op">,</span> <span class="op">*</span>read)<span class="op">;</span></span>
<span id="cb105-12"><a href="#cb105-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>)</span>
<span id="cb105-13"><a href="#cb105-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>)<span class="op">.</span>collect()<span class="op">;</span></span>
<span id="cb105-14"><a href="#cb105-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb105-15"><a href="#cb105-15" aria-hidden="true" tabindex="-1"></a><span class="co">// One writer:</span></span>
<span id="cb105-16"><a href="#cb105-16" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> data_clone <span class="op">=</span> <span class="pp">Arc::</span>clone(<span class="op">&amp;</span>data)<span class="op">;</span></span>
<span id="cb105-17"><a href="#cb105-17" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> writer <span class="op">=</span> <span class="pp">thread::</span>spawn(<span class="kw">move</span> <span class="op">||</span> <span class="op">{</span></span>
<span id="cb105-18"><a href="#cb105-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">mut</span> write <span class="op">=</span> data_clone<span class="op">.</span>write()<span class="op">.</span>unwrap()<span class="op">;</span></span>
<span id="cb105-19"><a href="#cb105-19" aria-hidden="true" tabindex="-1"></a>    write<span class="op">.</span>push(<span class="dv">4</span>)<span class="op">;</span></span>
<span id="cb105-20"><a href="#cb105-20" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>)<span class="op">;</span></span>
<span id="cb105-21"><a href="#cb105-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb105-22"><a href="#cb105-22" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> handle <span class="kw">in</span> handles <span class="op">{</span></span>
<span id="cb105-23"><a href="#cb105-23" aria-hidden="true" tabindex="-1"></a>    handle<span class="op">.</span>join()<span class="op">.</span>unwrap()<span class="op">;</span></span>
<span id="cb105-24"><a href="#cb105-24" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb105-25"><a href="#cb105-25" aria-hidden="true" tabindex="-1"></a>writer<span class="op">.</span>join()<span class="op">.</span>unwrap()<span class="op">;</span></span></code></pre></div>
<p><strong>Channels for message passing.</strong><br />
Use channels to communicate between threads:</p>
<div class="sourceCode" id="cb106"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb106-1"><a href="#cb106-1" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">std::sync::</span>mpsc<span class="op">;</span></span>
<span id="cb106-2"><a href="#cb106-2" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">std::</span>thread<span class="op">;</span></span>
<span id="cb106-3"><a href="#cb106-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb106-4"><a href="#cb106-4" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> (tx<span class="op">,</span> rx) <span class="op">=</span> <span class="pp">mpsc::</span>channel()<span class="op">;</span></span>
<span id="cb106-5"><a href="#cb106-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb106-6"><a href="#cb106-6" aria-hidden="true" tabindex="-1"></a><span class="pp">thread::</span>spawn(<span class="kw">move</span> <span class="op">||</span> <span class="op">{</span></span>
<span id="cb106-7"><a href="#cb106-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> messages <span class="op">=</span> <span class="pp">vec!</span>[<span class="st">&quot;hello&quot;</span><span class="op">,</span> <span class="st">&quot;from&quot;</span><span class="op">,</span> <span class="st">&quot;thread&quot;</span>]<span class="op">;</span></span>
<span id="cb106-8"><a href="#cb106-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> msg <span class="kw">in</span> messages <span class="op">{</span></span>
<span id="cb106-9"><a href="#cb106-9" aria-hidden="true" tabindex="-1"></a>        tx<span class="op">.</span>send(msg)<span class="op">.</span>unwrap()<span class="op">;</span></span>
<span id="cb106-10"><a href="#cb106-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb106-11"><a href="#cb106-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>)<span class="op">;</span></span>
<span id="cb106-12"><a href="#cb106-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb106-13"><a href="#cb106-13" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> received <span class="kw">in</span> rx <span class="op">{</span></span>
<span id="cb106-14"><a href="#cb106-14" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;Got: {}&quot;</span><span class="op">,</span> received)<span class="op">;</span></span>
<span id="cb106-15"><a href="#cb106-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The type system ensures you can’t send non-<code>Send</code> types
through channels.</p>
<p><strong>Atomic types for lock-free operations.</strong><br />
Use atomics for simple lock-free operations:</p>
<div class="sourceCode" id="cb107"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb107-1"><a href="#cb107-1" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">std::sync::atomic::</span><span class="op">{</span>AtomicUsize<span class="op">,</span> Ordering<span class="op">};</span></span>
<span id="cb107-2"><a href="#cb107-2" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">std::sync::</span>Arc<span class="op">;</span></span>
<span id="cb107-3"><a href="#cb107-3" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">std::</span>thread<span class="op">;</span></span>
<span id="cb107-4"><a href="#cb107-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-5"><a href="#cb107-5" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> counter <span class="op">=</span> <span class="pp">Arc::</span>new(<span class="pp">AtomicUsize::</span>new(<span class="dv">0</span>))<span class="op">;</span></span>
<span id="cb107-6"><a href="#cb107-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-7"><a href="#cb107-7" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> handles<span class="op">:</span> <span class="dt">Vec</span><span class="op">&lt;</span>_<span class="op">&gt;</span> <span class="op">=</span> (<span class="dv">0</span><span class="op">..</span><span class="dv">10</span>)<span class="op">.</span>map(<span class="op">|</span>_<span class="op">|</span> <span class="op">{</span></span>
<span id="cb107-8"><a href="#cb107-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> counter <span class="op">=</span> <span class="pp">Arc::</span>clone(<span class="op">&amp;</span>counter)<span class="op">;</span></span>
<span id="cb107-9"><a href="#cb107-9" aria-hidden="true" tabindex="-1"></a>    <span class="pp">thread::</span>spawn(<span class="kw">move</span> <span class="op">||</span> <span class="op">{</span></span>
<span id="cb107-10"><a href="#cb107-10" aria-hidden="true" tabindex="-1"></a>        counter<span class="op">.</span>fetch_add(<span class="dv">1</span><span class="op">,</span> <span class="pp">Ordering::</span>SeqCst)<span class="op">;</span></span>
<span id="cb107-11"><a href="#cb107-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>)</span>
<span id="cb107-12"><a href="#cb107-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>)<span class="op">.</span>collect()<span class="op">;</span></span>
<span id="cb107-13"><a href="#cb107-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-14"><a href="#cb107-14" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> handle <span class="kw">in</span> handles <span class="op">{</span></span>
<span id="cb107-15"><a href="#cb107-15" aria-hidden="true" tabindex="-1"></a>    handle<span class="op">.</span>join()<span class="op">.</span>unwrap()<span class="op">;</span></span>
<span id="cb107-16"><a href="#cb107-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb107-17"><a href="#cb107-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-18"><a href="#cb107-18" aria-hidden="true" tabindex="-1"></a><span class="pp">println!</span>(<span class="st">&quot;Result: {}&quot;</span><span class="op">,</span> counter<span class="op">.</span>load(<span class="pp">Ordering::</span>SeqCst))<span class="op">;</span></span></code></pre></div>
<hr />
<h2 id="takeaways-for-c-developers-10">Takeaways for C++ Developers</h2>
<p><strong>Mental model shift:</strong> - Thread safety is encoded in
the type system (<code>Send</code>, <code>Sync</code>) - The compiler
prevents data races—you can’t forget to lock - Shared ownership requires
<code>Arc</code> (explicit atomic reference counting) - Mutable shared
state requires <code>Mutex</code> or <code>RwLock</code></p>
<p><strong>Rules of thumb:</strong> - Use <code>Arc</code> for shared
ownership across threads - Use <code>Mutex</code> for shared mutable
state - Use <code>RwLock</code> for read-heavy workloads - Use channels
for message passing between threads - Use atomics for simple lock-free
operations</p>
<p><strong>Pitfalls:</strong> - <code>Rc</code> is not thread-safe—use
<code>Arc</code> instead - <code>RefCell</code> is not thread-safe—use
<code>Mutex</code> instead - The compiler prevents data races, not
deadlocks or race conditions</p>
<p>Rust eliminates data races at compile time. The cost is that you must
structure your code to satisfy the type system.</p>
<hr />
<h1 id="when-rust-feels-hardand-why">12. When Rust Feels Hard—and
Why</h1>
<blockquote>
<p>You’ve learned the rules, fought the borrow checker, and written code
that compiles. But it still feels harder than C++. That’s not a
failure—it’s the cost of the guarantees Rust provides.</p>
</blockquote>
<hr />
<h2 id="why-this-matters-to-a-c-developer-11">Why This Matters to a C++
Developer</h2>
<p>In C++, you can prototype quickly. You write code, it compiles, and
you iterate. If there’s a bug, you find it later—in testing, in code
review, or in production.</p>
<p>Rust doesn’t work that way. You fight the compiler upfront. You
restructure your code to satisfy the borrow checker. You add lifetime
annotations. You clone data when you’d prefer to borrow. The iteration
loop is slower.</p>
<p>This feels like friction. You know what you want to do. You know it
would work in C++. But Rust says no, and you have to figure out why.</p>
<p>The question is: is this friction worth it?</p>
<p>The answer depends on: - The size of your team - The lifespan of your
codebase - The cost of bugs in production - Your tolerance for upfront
complexity vs deferred debugging</p>
<p>Rust trades fast prototyping for fewer bugs. C++ trades compiler
flexibility for runtime vigilance. Neither is universally better—they
optimize for different constraints.</p>
<hr />
<h2 id="the-c-mental-model-11">The C++ Mental Model</h2>
<p>In C++, you optimize for <strong>iteration speed</strong>.</p>
<p><strong>The compiler is permissive.</strong><br />
It lets you write code that might be wrong. You find out later whether
it was correct. This is fast when you’re exploring, slow when you’re
debugging.</p>
<p><strong>Mistakes are deferred.</strong><br />
You write code, it compiles, and you test it. If there’s a bug, you fix
it. If the bug is subtle (data race, use-after-free), you might not find
it until production.</p>
<p><strong>Refactoring is risky.</strong><br />
You change a function signature, and the code still compiles. But now
some callers have dangling pointers, or race conditions, or memory
leaks. The compiler doesn’t tell you.</p>
<p><strong>Discipline scales poorly.</strong><br />
In a small team, everyone knows the rules. In a large team, with
turnover and deadlines, discipline breaks down. Bugs slip through.</p>
<p><strong>Tooling fills the gaps.</strong><br />
You use sanitizers, static analyzers, and code review to catch bugs. But
these are after-the-fact. They don’t prevent bugs—they find them.</p>
<p>This model works when: - You’re prototyping and need to move fast -
The team is small and experienced - The cost of bugs is low (you can
patch quickly)</p>
<hr />
<h2 id="where-the-model-breaks-down-11">Where the Model Breaks Down</h2>
<p>The problem is that <strong>the cost of bugs grows with
scale</strong>.</p>
<p><strong>Bugs are expensive.</strong><br />
A use-after-free in production can crash your service, corrupt data, or
create a security vulnerability. The cost of finding and fixing it is
high—much higher than preventing it upfront.</p>
<p><strong>Refactoring is fragile.</strong><br />
You change a function to take ownership instead of borrowing. The code
compiles. But now some callers have dangling pointers. You don’t find
out until production.</p>
<p><strong>Discipline doesn’t scale.</strong><br />
In a large codebase, with multiple teams and years of history,
conventions drift. Someone forgets to lock a mutex. Someone stores a raw
pointer that outlives the object. The compiler doesn’t notice.</p>
<p><strong>Tooling is incomplete.</strong><br />
Sanitizers catch many bugs, but not all. They don’t catch logic errors.
They don’t catch race conditions that only happen under load. They only
help if you run the code path that triggers the bug.</p>
<p><strong>The cost is deferred.</strong><br />
You write the code, it compiles, and you find out later whether it was
correct. By then, the bug is in production, and you’re debugging a crash
with no clear cause.</p>
<p>Rust inverts this. You pay the cost upfront, at compile time. The
compiler is strict. It rejects code that might be wrong. You fight the
borrow checker, you add lifetime annotations, you restructure your
code.</p>
<p>This is slower at first. But once the code compiles, whole classes of
bugs are gone: - No use-after-free - No dangling pointers - No data
races - No iterator invalidation</p>
<p>The trade-off is explicit: - Slower prototyping, fewer bugs - More
upfront complexity, less deferred debugging - Stricter compiler, safer
code</p>
<p>Whether this is worth it depends on your project. If you’re writing a
prototype that will be thrown away, C++ is faster. If you’re writing a
service that will run for years, with multiple teams, Rust’s guarantees
pay off.</p>
<p>The friction you feel isn’t Rust being difficult for no reason. It’s
Rust enforcing guarantees that C++ leaves to you. The question is
whether those guarantees are worth the cost.</p>
<hr />
<h2 id="rusts-model-11">Rust’s Model</h2>
<p>Rust doesn’t hide the complexity—it makes it explicit. The friction
you feel is the cost of compile-time guarantees.</p>
<p><strong>The compiler is strict upfront.</strong><br />
Rust rejects code that might be wrong. You fight the compiler until it’s
satisfied, then the code works.</p>
<div class="sourceCode" id="cb108"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb108-1"><a href="#cb108-1" aria-hidden="true" tabindex="-1"></a><span class="co">// This won&#39;t compile:</span></span>
<span id="cb108-2"><a href="#cb108-2" aria-hidden="true" tabindex="-1"></a><span class="co">// fn process() {</span></span>
<span id="cb108-3"><a href="#cb108-3" aria-hidden="true" tabindex="-1"></a><span class="co">//     let vec = vec![1, 2, 3];</span></span>
<span id="cb108-4"><a href="#cb108-4" aria-hidden="true" tabindex="-1"></a><span class="co">//     let first = &amp;vec[0];</span></span>
<span id="cb108-5"><a href="#cb108-5" aria-hidden="true" tabindex="-1"></a><span class="co">//     vec.push(4);  // Error: can&#39;t mutate while borrowed</span></span>
<span id="cb108-6"><a href="#cb108-6" aria-hidden="true" tabindex="-1"></a><span class="co">//     println!(&quot;{}&quot;, first);</span></span>
<span id="cb108-7"><a href="#cb108-7" aria-hidden="true" tabindex="-1"></a><span class="co">// }</span></span>
<span id="cb108-8"><a href="#cb108-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-9"><a href="#cb108-9" aria-hidden="true" tabindex="-1"></a><span class="co">// Restructure to satisfy the compiler:</span></span>
<span id="cb108-10"><a href="#cb108-10" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> process() <span class="op">{</span></span>
<span id="cb108-11"><a href="#cb108-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">mut</span> vec <span class="op">=</span> <span class="pp">vec!</span>[<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span>]<span class="op">;</span></span>
<span id="cb108-12"><a href="#cb108-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> first <span class="op">=</span> vec[<span class="dv">0</span>]<span class="op">;</span>  <span class="co">// Copy the value</span></span>
<span id="cb108-13"><a href="#cb108-13" aria-hidden="true" tabindex="-1"></a>    vec<span class="op">.</span>push(<span class="dv">4</span>)<span class="op">;</span></span>
<span id="cb108-14"><a href="#cb108-14" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> first)<span class="op">;</span></span>
<span id="cb108-15"><a href="#cb108-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The compiler forces you to think about ownership and lifetimes
upfront. This is slower when prototyping, but eliminates bugs.</p>
<p><strong>Cloning is sometimes the answer.</strong><br />
When the borrow checker fights you, cloning might be the right
solution:</p>
<div class="sourceCode" id="cb109"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb109-1"><a href="#cb109-1" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">std::collections::</span>HashMap<span class="op">;</span></span>
<span id="cb109-2"><a href="#cb109-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb109-3"><a href="#cb109-3" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> process_entries(map<span class="op">:</span> <span class="op">&amp;</span>HashMap<span class="op">&lt;</span><span class="dt">String</span><span class="op">,</span> <span class="dt">i32</span><span class="op">&gt;</span>) <span class="op">{</span></span>
<span id="cb109-4"><a href="#cb109-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Clone the keys - this is a common pattern when you need</span></span>
<span id="cb109-5"><a href="#cb109-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// to iterate while potentially modifying the map</span></span>
<span id="cb109-6"><a href="#cb109-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> keys<span class="op">:</span> <span class="dt">Vec</span><span class="op">&lt;</span><span class="dt">String</span><span class="op">&gt;</span> <span class="op">=</span> map<span class="op">.</span>keys()<span class="op">.</span>cloned()<span class="op">.</span>collect()<span class="op">;</span></span>
<span id="cb109-7"><a href="#cb109-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb109-8"><a href="#cb109-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> key <span class="kw">in</span> keys <span class="op">{</span></span>
<span id="cb109-9"><a href="#cb109-9" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Can now mutate map if needed</span></span>
<span id="cb109-10"><a href="#cb109-10" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;{}: {}&quot;</span><span class="op">,</span> key<span class="op">,</span> map<span class="op">.</span>get(<span class="op">&amp;</span>key)<span class="op">.</span>unwrap())<span class="op">;</span></span>
<span id="cb109-11"><a href="#cb109-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb109-12"><a href="#cb109-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Cloning has a cost, but it’s explicit. In C++, copies are often
hidden.</p>
<p><strong>Refactoring is safer.</strong><br />
When you change a function signature, the compiler tells you every place
that breaks:</p>
<div class="sourceCode" id="cb110"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb110-1"><a href="#cb110-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Change from borrowing to taking ownership:</span></span>
<span id="cb110-2"><a href="#cb110-2" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> process(data<span class="op">:</span> <span class="dt">Vec</span><span class="op">&lt;</span><span class="dt">i32</span><span class="op">&gt;</span>) <span class="op">{</span>  <span class="co">// Was: &amp;Vec&lt;i32&gt;</span></span>
<span id="cb110-3"><a href="#cb110-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Implementation</span></span>
<span id="cb110-4"><a href="#cb110-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb110-5"><a href="#cb110-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb110-6"><a href="#cb110-6" aria-hidden="true" tabindex="-1"></a><span class="co">// Every caller that still uses data afterward will fail to compile:</span></span>
<span id="cb110-7"><a href="#cb110-7" aria-hidden="true" tabindex="-1"></a><span class="co">// fn main() {</span></span>
<span id="cb110-8"><a href="#cb110-8" aria-hidden="true" tabindex="-1"></a><span class="co">//     let vec = vec![1, 2, 3];</span></span>
<span id="cb110-9"><a href="#cb110-9" aria-hidden="true" tabindex="-1"></a><span class="co">//     process(vec);</span></span>
<span id="cb110-10"><a href="#cb110-10" aria-hidden="true" tabindex="-1"></a><span class="co">//     println!(&quot;{:?}&quot;, vec);  // Compile error: value moved</span></span>
<span id="cb110-11"><a href="#cb110-11" aria-hidden="true" tabindex="-1"></a><span class="co">// }</span></span></code></pre></div>
<p>The compiler catches the mistake immediately, not in production.</p>
<p><strong>The cost is paid once.</strong><br />
You fight the compiler upfront. Once the code compiles, these bugs are
gone:</p>
<ul>
<li>No use-after-free</li>
<li>No dangling pointers</li>
<li>No data races</li>
<li>No iterator invalidation</li>
</ul>
<div class="sourceCode" id="cb111"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb111-1"><a href="#cb111-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> safe_processing() <span class="op">{</span></span>
<span id="cb111-2"><a href="#cb111-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">mut</span> vec <span class="op">=</span> <span class="pp">vec!</span>[<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span>]<span class="op">;</span></span>
<span id="cb111-3"><a href="#cb111-3" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb111-4"><a href="#cb111-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">// This is safe—compiler ensures it:</span></span>
<span id="cb111-5"><a href="#cb111-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> item <span class="kw">in</span> <span class="op">&amp;</span>vec <span class="op">{</span></span>
<span id="cb111-6"><a href="#cb111-6" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> item)<span class="op">;</span></span>
<span id="cb111-7"><a href="#cb111-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb111-8"><a href="#cb111-8" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb111-9"><a href="#cb111-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Can&#39;t modify during iteration:</span></span>
<span id="cb111-10"><a href="#cb111-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">// vec.push(4);  // Compile error</span></span>
<span id="cb111-11"><a href="#cb111-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><strong>When to use Rust vs C++.</strong></p>
<p>Use Rust when: - The codebase will live for years - Multiple teams
will maintain it - Bugs in production are expensive - You need thread
safety guarantees - You want to refactor with confidence</p>
<p>Use C++ when: - You’re prototyping and need to move fast - The team
is small and experienced - You need specific C++ libraries or ecosystems
- The cost of bugs is low (you can patch quickly) - You’re working with
existing C++ codebases</p>
<p><strong>The trade-off is explicit.</strong><br />
Rust: Slower prototyping, fewer bugs, safer refactoring.<br />
C++: Faster prototyping, more runtime vigilance, fragile
refactoring.</p>
<p>Neither is universally better. They optimize for different
constraints.</p>
<hr />
<h2 id="takeaways-for-c-developers-11">Takeaways for C++ Developers</h2>
<p><strong>Mental model shift:</strong> - The compiler is strict
upfront—you pay the cost before running the code - Cloning is explicit
and sometimes correct—not always a code smell - Refactoring is safer—the
compiler catches breaking changes - The friction is intentional—it’s
preventing bugs you’d find later</p>
<p><strong>Rules of thumb:</strong> - Fight the compiler for the first
week—then it becomes intuitive - When stuck, restructure your code—don’t
fight the borrow checker - Clone when necessary—explicit cost is better
than hidden bugs - Trust the compiler—if it says no, there’s a
reason</p>
<p><strong>Pitfalls:</strong> - Don’t try to write C++ in Rust—the
patterns don’t translate - The learning curve is steep—this is the cost
of the guarantees - Prototyping is slower—but production bugs are rarer
- Not every project needs Rust’s guarantees—choose the right tool</p>
<p>Rust doesn’t make programming easy. It makes certain classes of bugs
impossible. Whether that trade-off is worth it depends on your project’s
constraints.</p>
<hr />
<h1
id="appendix-a.-common-c-pitfalls-and-their-rust-counterparts">Appendix
A. Common C++ Pitfalls and Their Rust Counterparts</h1>
<blockquote>
<p>You’ve learned to avoid these bugs through experience—use-after-free,
iterator invalidation, data races. Rust prevents them at compile
time.</p>
</blockquote>
<hr />
<h2 id="why-this-matters-to-a-c-developer-12">Why This Matters to a C++
Developer</h2>
<p>You know the common pitfalls. You’ve debugged them, you’ve written
code reviews to catch them, and you’ve added sanitizers to find them.
These bugs are rare in well-written C++, but when they happen, they’re
catastrophic.</p>
<p>The patterns are familiar: - Use-after-free from dangling pointers -
Iterator invalidation from container modification - Data races from
unsynchronized access - Double-free from ownership confusion - Null
pointer dereferences</p>
<p>You handle these through: - Discipline and coding standards - Smart
pointers and RAII - Code review and pair programming - Sanitizers
(AddressSanitizer, ThreadSanitizer) - Testing and hoping you hit the
bug</p>
<p>This works most of the time. But the cost of missing one is
high—crashes, security vulnerabilities, data corruption.</p>
<hr />
<h2 id="the-c-mental-model-12">The C++ Mental Model</h2>
<p>In C++, these pitfalls are <strong>your responsibility to
avoid</strong>.</p>
<p><strong>Use-after-free is silent.</strong><br />
You delete an object, but a pointer to it still exists. Using that
pointer is undefined behavior.</p>
<div class="sourceCode" id="cb112"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb112-1"><a href="#cb112-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span><span class="op">*</span> ptr <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">(</span><span class="dv">42</span><span class="op">);</span></span>
<span id="cb112-2"><a href="#cb112-2" aria-hidden="true" tabindex="-1"></a><span class="kw">delete</span> ptr<span class="op">;</span></span>
<span id="cb112-3"><a href="#cb112-3" aria-hidden="true" tabindex="-1"></a><span class="op">*</span>ptr <span class="op">=</span> <span class="dv">10</span><span class="op">;</span>  <span class="co">// Undefined behavior. Might work, might crash.</span></span></code></pre></div>
<p><strong>Iterator invalidation is implicit.</strong><br />
Modifying a container can invalidate iterators. The compiler doesn’t
track this.</p>
<div class="sourceCode" id="cb113"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb113-1"><a href="#cb113-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> vec <span class="op">=</span> <span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">};</span></span>
<span id="cb113-2"><a href="#cb113-2" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> it <span class="op">=</span> vec<span class="op">.</span>begin<span class="op">();</span></span>
<span id="cb113-3"><a href="#cb113-3" aria-hidden="true" tabindex="-1"></a>vec<span class="op">.</span>push_back<span class="op">(</span><span class="dv">4</span><span class="op">);</span>  <span class="co">// May invalidate it</span></span>
<span id="cb113-4"><a href="#cb113-4" aria-hidden="true" tabindex="-1"></a><span class="op">*</span>it <span class="op">=</span> <span class="dv">10</span><span class="op">;</span>  <span class="co">// Undefined behavior if vec reallocated</span></span></code></pre></div>
<p><strong>Data races are unchecked.</strong><br />
Two threads accessing the same memory, at least one writing, no
synchronization—undefined behavior.</p>
<div class="sourceCode" id="cb114"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb114-1"><a href="#cb114-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> counter <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb114-2"><a href="#cb114-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-3"><a href="#cb114-3" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> increment<span class="op">()</span> <span class="op">{</span></span>
<span id="cb114-4"><a href="#cb114-4" aria-hidden="true" tabindex="-1"></a>    counter<span class="op">++;</span>  <span class="co">// Data race if called from multiple threads</span></span>
<span id="cb114-5"><a href="#cb114-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><strong>Null pointers are everywhere.</strong><br />
Any pointer might be null. You have to check, or you get undefined
behavior.</p>
<div class="sourceCode" id="cb115"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb115-1"><a href="#cb115-1" aria-hidden="true" tabindex="-1"></a>Widget<span class="op">*</span> w <span class="op">=</span> get_widget<span class="op">();</span></span>
<span id="cb115-2"><a href="#cb115-2" aria-hidden="true" tabindex="-1"></a>w<span class="op">-&gt;</span>process<span class="op">();</span>  <span class="co">// Crash if w is null</span></span></code></pre></div>
<hr />
<h2 id="where-the-model-breaks-down-12">Where the Model Breaks Down</h2>
<p>These bugs are <strong>invisible to the compiler</strong>.</p>
<p><strong>The compiler can’t help.</strong><br />
It doesn’t know which pointers are valid, which iterators are
invalidated, or which data is shared between threads. You have to get it
right every time.</p>
<p><strong>Bugs are deferred.</strong><br />
The code compiles. It might even work in testing. But in production,
under load, with a specific execution order, it crashes.</p>
<p><strong>Sanitizers are incomplete.</strong><br />
AddressSanitizer catches many use-after-free bugs, but not all.
ThreadSanitizer catches data races, but only if you execute the racy
code path. They’re tools, not guarantees.</p>
<p><strong>Scale amplifies risk.</strong><br />
In a small codebase, you know where every pointer comes from. In a large
codebase, with multiple teams and years of history, these bugs slip
through.</p>
<hr />
<h2 id="rusts-model-12">Rust’s Model</h2>
<p>Rust prevents these pitfalls at compile time. Not through
discipline—through the type system.</p>
<h3 id="pitfall-1-use-after-free">Pitfall 1: Use-After-Free</h3>
<p><strong>C++ version:</strong></p>
<div class="sourceCode" id="cb116"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb116-1"><a href="#cb116-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>unique_ptr<span class="op">&lt;</span>Widget<span class="op">&gt;</span> w <span class="op">=</span> <span class="bu">std::</span>make_unique<span class="op">&lt;</span>Widget<span class="op">&gt;();</span></span>
<span id="cb116-2"><a href="#cb116-2" aria-hidden="true" tabindex="-1"></a>Widget<span class="op">*</span> raw <span class="op">=</span> w<span class="op">.</span>get<span class="op">();</span></span>
<span id="cb116-3"><a href="#cb116-3" aria-hidden="true" tabindex="-1"></a>w<span class="op">.</span>reset<span class="op">();</span></span>
<span id="cb116-4"><a href="#cb116-4" aria-hidden="true" tabindex="-1"></a>raw<span class="op">-&gt;</span>process<span class="op">();</span>  <span class="co">// Use-after-free. Compiles.</span></span></code></pre></div>
<p><strong>Rust version:</strong></p>
<div class="sourceCode" id="cb117"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb117-1"><a href="#cb117-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> w <span class="op">=</span> <span class="dt">Box</span><span class="pp">::</span>new(<span class="pp">Widget::</span>new())<span class="op">;</span></span>
<span id="cb117-2"><a href="#cb117-2" aria-hidden="true" tabindex="-1"></a><span class="co">// let raw = &amp;*w;</span></span>
<span id="cb117-3"><a href="#cb117-3" aria-hidden="true" tabindex="-1"></a>drop(w)<span class="op">;</span></span>
<span id="cb117-4"><a href="#cb117-4" aria-hidden="true" tabindex="-1"></a><span class="co">// raw.process();  // Compile error: w doesn&#39;t live long enough</span></span></code></pre></div>
<p>The compiler tracks lifetimes. You can’t use a reference after the
owner is dropped.</p>
<h3 id="pitfall-2-iterator-invalidation">Pitfall 2: Iterator
Invalidation</h3>
<p><strong>C++ version:</strong></p>
<div class="sourceCode" id="cb118"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb118-1"><a href="#cb118-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> vec <span class="op">=</span> <span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">};</span></span>
<span id="cb118-2"><a href="#cb118-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span><span class="op">&amp;</span> first <span class="op">=</span> vec<span class="op">[</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb118-3"><a href="#cb118-3" aria-hidden="true" tabindex="-1"></a>vec<span class="op">.</span>push_back<span class="op">(</span><span class="dv">4</span><span class="op">);</span></span>
<span id="cb118-4"><a href="#cb118-4" aria-hidden="true" tabindex="-1"></a>first <span class="op">=</span> <span class="dv">10</span><span class="op">;</span>  <span class="co">// Undefined behavior if vec reallocated</span></span></code></pre></div>
<p><strong>Rust version:</strong></p>
<div class="sourceCode" id="cb119"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb119-1"><a href="#cb119-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">mut</span> vec <span class="op">=</span> <span class="pp">vec!</span>[<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span>]<span class="op">;</span></span>
<span id="cb119-2"><a href="#cb119-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> first <span class="op">=</span> <span class="op">&amp;</span>vec[<span class="dv">0</span>]<span class="op">;</span></span>
<span id="cb119-3"><a href="#cb119-3" aria-hidden="true" tabindex="-1"></a><span class="co">// vec.push(4);  // Compile error: can&#39;t mutate while borrowed</span></span>
<span id="cb119-4"><a href="#cb119-4" aria-hidden="true" tabindex="-1"></a><span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> first)<span class="op">;</span></span></code></pre></div>
<p>The borrow checker prevents mutation while a reference exists.</p>
<h3 id="pitfall-3-data-races">Pitfall 3: Data Races</h3>
<p><strong>C++ version:</strong></p>
<div class="sourceCode" id="cb120"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb120-1"><a href="#cb120-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> counter <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb120-2"><a href="#cb120-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb120-3"><a href="#cb120-3" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>thread t1<span class="op">([&amp;]()</span> <span class="op">{</span> counter<span class="op">++;</span> <span class="op">});</span></span>
<span id="cb120-4"><a href="#cb120-4" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>thread t2<span class="op">([&amp;]()</span> <span class="op">{</span> counter<span class="op">++;</span> <span class="op">});</span></span>
<span id="cb120-5"><a href="#cb120-5" aria-hidden="true" tabindex="-1"></a><span class="co">// Data race. Undefined behavior.</span></span></code></pre></div>
<p><strong>Rust version:</strong></p>
<div class="sourceCode" id="cb121"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb121-1"><a href="#cb121-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">mut</span> counter <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb121-2"><a href="#cb121-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb121-3"><a href="#cb121-3" aria-hidden="true" tabindex="-1"></a><span class="co">// This won&#39;t compile:</span></span>
<span id="cb121-4"><a href="#cb121-4" aria-hidden="true" tabindex="-1"></a><span class="co">// let t1 = std::thread::spawn(|| { counter += 1; });</span></span>
<span id="cb121-5"><a href="#cb121-5" aria-hidden="true" tabindex="-1"></a><span class="co">// Error: closure may outlive the current function, and</span></span>
<span id="cb121-6"><a href="#cb121-6" aria-hidden="true" tabindex="-1"></a><span class="co">// `counter` cannot be shared between threads safely</span></span>
<span id="cb121-7"><a href="#cb121-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb121-8"><a href="#cb121-8" aria-hidden="true" tabindex="-1"></a><span class="co">// Correct version with Arc&lt;Mutex&gt;:</span></span>
<span id="cb121-9"><a href="#cb121-9" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">std::sync::</span><span class="op">{</span>Arc<span class="op">,</span> Mutex<span class="op">};</span></span>
<span id="cb121-10"><a href="#cb121-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb121-11"><a href="#cb121-11" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> counter <span class="op">=</span> <span class="pp">Arc::</span>new(<span class="pp">Mutex::</span>new(<span class="dv">0</span>))<span class="op">;</span></span>
<span id="cb121-12"><a href="#cb121-12" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> c1 <span class="op">=</span> <span class="pp">Arc::</span>clone(<span class="op">&amp;</span>counter)<span class="op">;</span></span>
<span id="cb121-13"><a href="#cb121-13" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> c2 <span class="op">=</span> <span class="pp">Arc::</span>clone(<span class="op">&amp;</span>counter)<span class="op">;</span></span>
<span id="cb121-14"><a href="#cb121-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb121-15"><a href="#cb121-15" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> t1 <span class="op">=</span> <span class="pp">std::thread::</span>spawn(<span class="kw">move</span> <span class="op">||</span> <span class="op">{</span></span>
<span id="cb121-16"><a href="#cb121-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">*</span>c1<span class="op">.</span>lock()<span class="op">.</span>unwrap() <span class="op">+=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb121-17"><a href="#cb121-17" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>)<span class="op">;</span></span>
<span id="cb121-18"><a href="#cb121-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb121-19"><a href="#cb121-19" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> t2 <span class="op">=</span> <span class="pp">std::thread::</span>spawn(<span class="kw">move</span> <span class="op">||</span> <span class="op">{</span></span>
<span id="cb121-20"><a href="#cb121-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">*</span>c2<span class="op">.</span>lock()<span class="op">.</span>unwrap() <span class="op">+=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb121-21"><a href="#cb121-21" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>)<span class="op">;</span></span>
<span id="cb121-22"><a href="#cb121-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb121-23"><a href="#cb121-23" aria-hidden="true" tabindex="-1"></a>t1<span class="op">.</span>join()<span class="op">.</span>unwrap()<span class="op">;</span></span>
<span id="cb121-24"><a href="#cb121-24" aria-hidden="true" tabindex="-1"></a>t2<span class="op">.</span>join()<span class="op">.</span>unwrap()<span class="op">;</span></span></code></pre></div>
<p>The type system enforces synchronization. You can’t share mutable
state without a <code>Mutex</code>.</p>
<h3 id="pitfall-4-double-free">Pitfall 4: Double-Free</h3>
<p><strong>C++ version:</strong></p>
<div class="sourceCode" id="cb122"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb122-1"><a href="#cb122-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span><span class="op">*</span> ptr <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">(</span><span class="dv">42</span><span class="op">);</span></span>
<span id="cb122-2"><a href="#cb122-2" aria-hidden="true" tabindex="-1"></a><span class="kw">delete</span> ptr<span class="op">;</span></span>
<span id="cb122-3"><a href="#cb122-3" aria-hidden="true" tabindex="-1"></a><span class="kw">delete</span> ptr<span class="op">;</span>  <span class="co">// Double-free. Undefined behavior.</span></span></code></pre></div>
<p><strong>Rust version:</strong></p>
<div class="sourceCode" id="cb123"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb123-1"><a href="#cb123-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> b <span class="op">=</span> <span class="dt">Box</span><span class="pp">::</span>new(<span class="dv">42</span>)<span class="op">;</span></span>
<span id="cb123-2"><a href="#cb123-2" aria-hidden="true" tabindex="-1"></a>drop(b)<span class="op">;</span></span>
<span id="cb123-3"><a href="#cb123-3" aria-hidden="true" tabindex="-1"></a><span class="co">// drop(b);  // Compile error: value moved</span></span></code></pre></div>
<p>The compiler prevents using a value after it’s been
moved/dropped.</p>
<h3 id="pitfall-5-null-pointer-dereference">Pitfall 5: Null Pointer
Dereference</h3>
<p><strong>C++ version:</strong></p>
<div class="sourceCode" id="cb124"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb124-1"><a href="#cb124-1" aria-hidden="true" tabindex="-1"></a>Widget<span class="op">*</span> w <span class="op">=</span> find_widget<span class="op">(</span><span class="st">&quot;foo&quot;</span><span class="op">);</span></span>
<span id="cb124-2"><a href="#cb124-2" aria-hidden="true" tabindex="-1"></a>w<span class="op">-&gt;</span>process<span class="op">();</span>  <span class="co">// Crash if w is null</span></span></code></pre></div>
<p><strong>Rust version:</strong></p>
<div class="sourceCode" id="cb125"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb125-1"><a href="#cb125-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> find_widget(name<span class="op">:</span> <span class="op">&amp;</span><span class="dt">str</span>) <span class="op">-&gt;</span> <span class="dt">Option</span><span class="op">&lt;</span>Widget<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb125-2"><a href="#cb125-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Returns Some(widget) or None</span></span>
<span id="cb125-3"><a href="#cb125-3" aria-hidden="true" tabindex="-1"></a>    <span class="cn">None</span></span>
<span id="cb125-4"><a href="#cb125-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb125-5"><a href="#cb125-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb125-6"><a href="#cb125-6" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> w <span class="op">=</span> find_widget(<span class="st">&quot;foo&quot;</span>)<span class="op">;</span></span>
<span id="cb125-7"><a href="#cb125-7" aria-hidden="true" tabindex="-1"></a><span class="co">// w.process();  // Compile error: Option&lt;Widget&gt; doesn&#39;t have process()</span></span>
<span id="cb125-8"><a href="#cb125-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb125-9"><a href="#cb125-9" aria-hidden="true" tabindex="-1"></a><span class="co">// Must handle None case:</span></span>
<span id="cb125-10"><a href="#cb125-10" aria-hidden="true" tabindex="-1"></a><span class="cf">match</span> w <span class="op">{</span></span>
<span id="cb125-11"><a href="#cb125-11" aria-hidden="true" tabindex="-1"></a>    <span class="cn">Some</span>(widget) <span class="op">=&gt;</span> widget<span class="op">.</span>process()<span class="op">,</span></span>
<span id="cb125-12"><a href="#cb125-12" aria-hidden="true" tabindex="-1"></a>    <span class="cn">None</span> <span class="op">=&gt;</span> <span class="pp">println!</span>(<span class="st">&quot;Widget not found&quot;</span>)<span class="op">,</span></span>
<span id="cb125-13"><a href="#cb125-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb125-14"><a href="#cb125-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb125-15"><a href="#cb125-15" aria-hidden="true" tabindex="-1"></a><span class="co">// Or use if let:</span></span>
<span id="cb125-16"><a href="#cb125-16" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="kw">let</span> <span class="cn">Some</span>(widget) <span class="op">=</span> w <span class="op">{</span></span>
<span id="cb125-17"><a href="#cb125-17" aria-hidden="true" tabindex="-1"></a>    widget<span class="op">.</span>process()<span class="op">;</span></span>
<span id="cb125-18"><a href="#cb125-18" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb125-19"><a href="#cb125-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb125-20"><a href="#cb125-20" aria-hidden="true" tabindex="-1"></a><span class="co">// Note: If returning a reference instead of owned value:</span></span>
<span id="cb125-21"><a href="#cb125-21" aria-hidden="true" tabindex="-1"></a><span class="co">// fn find_widget_ref(name: &amp;str) -&gt; Option&lt;&amp;Widget&gt;</span></span>
<span id="cb125-22"><a href="#cb125-22" aria-hidden="true" tabindex="-1"></a><span class="co">// The lifetime of the reference is tied to the source.</span></span></code></pre></div>
<p><code>Option&lt;T&gt;</code> makes null explicit. You must handle the
<code>None</code> case.</p>
<h3 id="pitfall-6-use-after-move">Pitfall 6: Use-After-Move</h3>
<p><strong>C++ version:</strong></p>
<div class="sourceCode" id="cb126"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb126-1"><a href="#cb126-1" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> ptr <span class="op">=</span> <span class="bu">std::</span>make_unique<span class="op">&lt;</span>Widget<span class="op">&gt;();</span></span>
<span id="cb126-2"><a href="#cb126-2" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> ptr2 <span class="op">=</span> <span class="bu">std::</span>move<span class="op">(</span>ptr<span class="op">);</span></span>
<span id="cb126-3"><a href="#cb126-3" aria-hidden="true" tabindex="-1"></a>ptr<span class="op">-&gt;</span>process<span class="op">();</span>  <span class="co">// Undefined behavior. Compiles.</span></span></code></pre></div>
<p><strong>Rust version:</strong></p>
<div class="sourceCode" id="cb127"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb127-1"><a href="#cb127-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> w <span class="op">=</span> <span class="dt">Box</span><span class="pp">::</span>new(<span class="pp">Widget::</span>new())<span class="op">;</span></span>
<span id="cb127-2"><a href="#cb127-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> w2 <span class="op">=</span> w<span class="op">;</span>  <span class="co">// w moved to w2</span></span>
<span id="cb127-3"><a href="#cb127-3" aria-hidden="true" tabindex="-1"></a><span class="co">// w.process();  // Compile error: value moved</span></span></code></pre></div>
<p>The compiler prevents using a value after it’s been moved.</p>
<hr />
<h2 id="takeaways-for-c-developers-12">Takeaways for C++ Developers</h2>
<p><strong>Mental model shift:</strong> - Pitfalls you avoid through
discipline are prevented by the compiler - The borrow checker enforces
what you track mentally - <code>Option&lt;T&gt;</code> makes null
explicit—you must handle it - Move semantics are checked—you can’t use
after move</p>
<p><strong>Rust prevents at compile time:</strong> - Use-after-free →
Lifetime tracking - Iterator invalidation → Borrow checker - Data races
→ <code>Send</code>/<code>Sync</code> traits - Double-free → Move
semantics - Null dereference → <code>Option&lt;T&gt;</code> -
Use-after-move → Ownership tracking</p>
<p><strong>Rules of thumb:</strong> - If it compiles in Rust, these bugs
are impossible (outside <code>unsafe</code>) - The compiler errors that
frustrate you are preventing bugs - <code>Option&lt;T&gt;</code> is
better than null pointers—handle both cases -
<code>Arc&lt;Mutex&lt;T&gt;&gt;</code> is verbose, but prevents data
races</p>
<p><strong>Pitfalls:</strong> - The compiler won’t let you write code
that “might” be safe - You must restructure code to satisfy the borrow
checker - Cloning to avoid borrow checker fights is sometimes correct -
These guarantees only apply to safe Rust—<code>unsafe</code> is your
responsibility</p>
<p>Rust doesn’t make you a better programmer. It makes the compiler
catch the bugs you’d spend days debugging in C++.</p>
<hr />
<h1 id="appendix-b.-reading-rust-compiler-errors-like-a-human">Appendix
B. Reading Rust Compiler Errors Like a Human</h1>
<blockquote>
<p>C++ template errors span hundreds of lines and point deep into the
standard library. Rust errors are verbose but structured—once you learn
to read them, they’re actually helpful.</p>
</blockquote>
<hr />
<h2 id="why-this-matters-to-a-c-developer-13">Why This Matters to a C++
Developer</h2>
<p>You’re used to compiler errors that are cryptic, verbose, and often
misleading. Template errors show you what went wrong deep in the
implementation, not what you did wrong at the call site.</p>
<p>In C++, you handle errors by: - Scrolling through pages of template
instantiation traces - Guessing what the compiler actually wants -
Commenting out code until it compiles - Searching Stack Overflow for the
error message - Learning to recognize patterns in the noise</p>
<p>Rust errors are different. They’re verbose, but they’re structured.
They tell you: - What you tried to do - Why it’s not allowed - Where the
conflict is - How to fix it (often with suggestions)</p>
<p>The first week, they’ll feel overwhelming. After that, they become a
teaching tool.</p>
<hr />
<h2 id="the-c-mental-model-13">The C++ Mental Model</h2>
<p>In C++, compiler errors are <strong>diagnostic noise</strong>.</p>
<p><strong>Template errors are incomprehensible.</strong><br />
A simple mistake generates hundreds of lines of errors, deep in the
standard library.</p>
<div class="sourceCode" id="cb128"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb128-1"><a href="#cb128-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb128-2"><a href="#cb128-2" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> process<span class="op">(</span>T<span class="op">&amp;</span> container<span class="op">)</span> <span class="op">{</span></span>
<span id="cb128-3"><a href="#cb128-3" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>sort<span class="op">(</span>container<span class="op">.</span>begin<span class="op">(),</span> container<span class="op">.</span>end<span class="op">());</span></span>
<span id="cb128-4"><a href="#cb128-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb128-5"><a href="#cb128-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb128-6"><a href="#cb128-6" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>list<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> lst <span class="op">=</span> <span class="op">{</span><span class="dv">3</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">};</span></span>
<span id="cb128-7"><a href="#cb128-7" aria-hidden="true" tabindex="-1"></a>process<span class="op">(</span>lst<span class="op">);</span>  <span class="co">// Error: no match for &#39;operator-&#39; in &#39;__last - __first&#39;</span></span>
<span id="cb128-8"><a href="#cb128-8" aria-hidden="true" tabindex="-1"></a>               <span class="co">// (followed by 50+ lines of template instantiation)</span></span></code></pre></div>
<p>The error doesn’t say “std::list doesn’t have random-access
iterators.” It shows you where <code>std::sort</code> failed, deep in
the implementation.</p>
<p><strong>Errors point to the wrong place.</strong><br />
The error appears where the template is instantiated, not where you made
the mistake.</p>
<p><strong>No suggestions.</strong><br />
The compiler tells you what’s wrong, but not how to fix it. You have to
figure that out.</p>
<p><strong>SFINAE errors are silent.</strong><br />
If a template substitution fails, the compiler just tries the next
overload. You don’t know why the first one didn’t match.</p>
<hr />
<h2 id="where-the-model-breaks-down-13">Where the Model Breaks Down</h2>
<p><strong>Errors are overwhelming.</strong><br />
A single mistake generates pages of output. You have to learn to ignore
most of it and find the relevant line.</p>
<p><strong>Errors are misleading.</strong><br />
The compiler shows you where the code failed, not why. You have to work
backwards from the error to the cause.</p>
<p><strong>No learning feedback.</strong><br />
The compiler doesn’t teach you. It just tells you “no” and expects you
to figure out why.</p>
<p><strong>Concept errors (C++20) help, but aren’t
universal.</strong><br />
Concepts improve error messages, but most codebases don’t use them
yet.</p>
<hr />
<h2 id="rusts-model-13">Rust’s Model</h2>
<p>Rust errors are structured and informative. They tell you what’s
wrong, where, and often how to fix it.</p>
<h3 id="error-anatomy">Error Anatomy</h3>
<p>A typical Rust error has: 1. <strong>Error code</strong> (e.g.,
<code>E0382</code>) 2. <strong>Error message</strong> (what you did
wrong) 3. <strong>Location</strong> (file, line, column) 4. <strong>Code
snippet</strong> with annotations 5. <strong>Explanation</strong> (why
it’s wrong) 6. <strong>Suggestion</strong> (how to fix it)</p>
<h3 id="example-1-use-after-move">Example 1: Use After Move</h3>
<div class="sourceCode" id="cb129"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb129-1"><a href="#cb129-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb129-2"><a href="#cb129-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> s <span class="op">=</span> <span class="dt">String</span><span class="pp">::</span>from(<span class="st">&quot;hello&quot;</span>)<span class="op">;</span></span>
<span id="cb129-3"><a href="#cb129-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> s2 <span class="op">=</span> s<span class="op">;</span></span>
<span id="cb129-4"><a href="#cb129-4" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> s)<span class="op">;</span></span>
<span id="cb129-5"><a href="#cb129-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><strong>Error:</strong></p>
<pre><code>error[E0382]: borrow of moved value: `s`
 --&gt; src/main.rs:4:20
  |
2 |     let s = String::from(&quot;hello&quot;);
  |         - move occurs because `s` has type `String`, which does not implement the `Copy` trait
3 |     let s2 = s;
  |              - value moved here
4 |     println!(&quot;{}&quot;, s);
  |                    ^ value borrowed here after move
  |
  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)
help: consider cloning the value if the performance cost is acceptable
  |
3 |     let s2 = s.clone();
  |               ++++++++</code></pre>
<p>(The note about macro expansion can be ignored - it’s just showing
that println! is implemented as a macro. The key error is above.)</p>
<p><strong>What it tells you:</strong> - You moved <code>s</code> on
line 3 - You tried to use it on line 4 - <code>String</code> doesn’t
implement <code>Copy</code> - Suggestion: use <code>.clone()</code> if
you want a copy</p>
<h3 id="example-2-borrow-checker-violation">Example 2: Borrow Checker
Violation</h3>
<div class="sourceCode" id="cb131"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb131-1"><a href="#cb131-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb131-2"><a href="#cb131-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">mut</span> vec <span class="op">=</span> <span class="pp">vec!</span>[<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span>]<span class="op">;</span></span>
<span id="cb131-3"><a href="#cb131-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> first <span class="op">=</span> <span class="op">&amp;</span>vec[<span class="dv">0</span>]<span class="op">;</span></span>
<span id="cb131-4"><a href="#cb131-4" aria-hidden="true" tabindex="-1"></a>    vec<span class="op">.</span>push(<span class="dv">4</span>)<span class="op">;</span></span>
<span id="cb131-5"><a href="#cb131-5" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> first)<span class="op">;</span></span>
<span id="cb131-6"><a href="#cb131-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><strong>Error:</strong></p>
<pre><code>error[E0502]: cannot borrow `vec` as mutable because it is also borrowed as immutable
 --&gt; src/main.rs:4:5
  |
3 |     let first = &amp;vec[0];
  |                  --- immutable borrow occurs here
4 |     vec.push(4);
  |     ^^^^^^^^^^^ mutable borrow occurs here
5 |     println!(&quot;{}&quot;, first);
  |                    ----- immutable borrow later used here</code></pre>
<p><strong>What it tells you:</strong> - You borrowed <code>vec</code>
immutably on line 3 - You tried to borrow it mutably on line 4 - The
immutable borrow is still in use on line 5 - You can’t have both at the
same time</p>
<h3 id="example-3-lifetime-error">Example 3: Lifetime Error</h3>
<div class="sourceCode" id="cb133"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb133-1"><a href="#cb133-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> longest(s1<span class="op">:</span> <span class="op">&amp;</span><span class="dt">str</span><span class="op">,</span> s2<span class="op">:</span> <span class="op">&amp;</span><span class="dt">str</span>) <span class="op">-&gt;</span> <span class="op">&amp;</span><span class="dt">str</span> <span class="op">{</span></span>
<span id="cb133-2"><a href="#cb133-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> s1<span class="op">.</span>len() <span class="op">&gt;</span> s2<span class="op">.</span>len() <span class="op">{</span> s1 <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span> s2 <span class="op">}</span></span>
<span id="cb133-3"><a href="#cb133-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><strong>Error:</strong></p>
<pre><code>error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:1:38
  |
1 | fn longest(s1: &amp;str, s2: &amp;str) -&gt; &amp;str {
  |                ----      ----     ^ expected named lifetime parameter
  |
  = help: this function&#39;s return type contains a borrowed value, but the signature does not say whether it is borrowed from `s1` or `s2`
help: consider introducing a named lifetime parameter
  |
1 | fn longest&lt;&#39;a&gt;(s1: &amp;&#39;a str, s2: &amp;&#39;a str) -&gt; &amp;&#39;a str {
  |           ++++      ++           ++          ++</code></pre>
<p><strong>What it tells you:</strong> - The return type is a reference
- The compiler doesn’t know which input it borrows from - Suggestion:
add lifetime annotations</p>
<h3 id="example-4-type-mismatch">Example 4: Type Mismatch</h3>
<div class="sourceCode" id="cb135"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb135-1"><a href="#cb135-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb135-2"><a href="#cb135-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> x<span class="op">:</span> <span class="dt">i32</span> <span class="op">=</span> <span class="st">&quot;hello&quot;</span><span class="op">;</span></span>
<span id="cb135-3"><a href="#cb135-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><strong>Error:</strong></p>
<pre><code>error[E0308]: mismatched types
 --&gt; src/main.rs:2:18
  |
2 |     let x: i32 = &quot;hello&quot;;
  |            ---   ^^^^^^^ expected `i32`, found `&amp;str`
  |            |
  |            expected due to this</code></pre>
<p><strong>What it tells you:</strong> - You declared <code>x</code> as
<code>i32</code> - You assigned a <code>&amp;str</code> - Clear type
mismatch</p>
<h3 id="reading-strategies">Reading Strategies</h3>
<p><strong>1. Start with the error code.</strong><br />
<code>E0382</code>, <code>E0502</code>, etc. You can look these up:
<code>rustc --explain E0382</code></p>
<p><strong>2. Read the first line.</strong><br />
It tells you what you did wrong in plain English.</p>
<p><strong>3. Look at the annotations.</strong><br />
The <code>^</code>, <code>-</code>, and <code>|</code> markers show you
exactly where the problem is.</p>
<p><strong>4. Read the help text.</strong><br />
Often includes a suggestion or explanation.</p>
<p><strong>5. Ignore macro expansion notes initially.</strong><br />
They’re usually not relevant to your mistake.</p>
<p><strong>6. Fix one error at a time.</strong><br />
Later errors often disappear when you fix the first one.</p>
<hr />
<h2 id="takeaways-for-c-developers-13">Takeaways for C++ Developers</h2>
<p><strong>Mental model shift:</strong> - Rust errors are teaching
tools, not just diagnostics - The compiler is trying to help, not just
reject your code - Error codes (<code>E0382</code>) are documentation
references - Suggestions are often correct—try them</p>
<p><strong>Reading strategy:</strong> 1. Read the first line (what you
did wrong) 2. Look at the code annotations (where the conflict is) 3.
Read the help text (how to fix it) 4. Try the suggestion if provided 5.
Look up the error code if confused:
<code>rustc --explain E0382</code></p>
<p><strong>Common error patterns:</strong> - <code>E0382</code>: Use
after move → You moved a value and tried to use it - <code>E0502</code>:
Borrow conflict → You tried to borrow mutably while borrowed immutably -
<code>E0106</code>: Missing lifetime → The compiler can’t infer the
lifetime - <code>E0308</code>: Type mismatch → You used the wrong type -
<code>E0499</code>: Multiple mutable borrows → You tried to borrow
mutably twice</p>
<p><strong>Pitfalls:</strong> - Don’t ignore the error and try random
fixes—read it - Don’t fight the compiler—it’s preventing a bug -
Suggestions aren’t always optimal—but they’re a starting point -
Multiple errors often have one root cause—fix the first one</p>
<p>Rust errors are verbose, but they’re structured. Once you learn to
read them, they’re more helpful than C++ errors.</p>
<hr />
<h1 id="appendix-c.-mental-model-cheat-sheet-c-rust">Appendix C. Mental
Model Cheat Sheet (C++ → Rust)</h1>
<blockquote>
<p>You think in C++ patterns—pointers, references, RAII, templates.
Here’s how they map to Rust, and where they don’t.</p>
</blockquote>
<hr />
<h2 id="why-this-matters-to-a-c-developer-14">Why This Matters to a C++
Developer</h2>
<p>You have 15+ years of C++ intuition. You know when to use
<code>unique_ptr</code>, when to pass by reference, when to use
<code>const</code>. These patterns are muscle memory.</p>
<p>Rust has similar concepts, but different rules. Your C++ intuition
will get you 80% of the way there—but the remaining 20% is where you’ll
fight the compiler.</p>
<p>This cheat sheet maps C++ patterns to Rust equivalents: - What
translates directly - What requires restructuring - What doesn’t exist
in Rust - What Rust has that C++ doesn’t</p>
<p>Use this as a reference when you’re stuck, or when a C++ pattern
doesn’t work in Rust.</p>
<hr />
<h2 id="the-c-mental-model-14">The C++ Mental Model</h2>
<p>In C++, you think in terms of: - Ownership (implicit, by convention)
- References (aliases, unchecked) - Smart pointers (opt-in RAII) -
Templates (duck-typed, checked at instantiation) - Exceptions (invisible
control flow) - Mutability (default, const is opt-in)</p>
<p>These patterns work through discipline and conventions. The compiler
trusts you to get it right.</p>
<hr />
<h2 id="where-the-model-breaks-down-14">Where the Model Breaks Down</h2>
<p>C++ patterns don’t always map cleanly to Rust: - Ownership is
explicit, not implicit - References have lifetimes that the compiler
tracks - RAII is mandatory, not opt-in - Generics use traits, not duck
typing - Errors are values, not exceptions - Mutability is opt-in, not
default</p>
<p>You’ll need to adjust your mental model. This cheat sheet shows you
how.</p>
<hr />
<h2 id="rusts-model-14">Rust’s Model</h2>
<h3 id="ownership-and-memory-management">Ownership and Memory
Management</h3>
<table>
<colgroup>
<col style="width: 35%" />
<col style="width: 45%" />
<col style="width: 18%" />
</colgroup>
<thead>
<tr>
<th>C++ Pattern</th>
<th>Rust Equivalent</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>T*</code> (raw pointer)</td>
<td><code>*const T</code> or <code>*mut T</code></td>
<td>Requires <code>unsafe</code> to dereference</td>
</tr>
<tr>
<td><code>T&amp;</code> (reference)</td>
<td><code>&amp;T</code></td>
<td>Immutable by default, lifetime-tracked</td>
</tr>
<tr>
<td><code>T&amp;</code> (mutable)</td>
<td><code>&amp;mut T</code></td>
<td>Exclusive mutable access</td>
</tr>
<tr>
<td><code>const T&amp;</code></td>
<td><code>&amp;T</code></td>
<td>Immutable reference</td>
</tr>
<tr>
<td><code>std::unique_ptr&lt;T&gt;</code></td>
<td><code>Box&lt;T&gt;</code></td>
<td>Heap allocation, single owner</td>
</tr>
<tr>
<td><code>std::shared_ptr&lt;T&gt;</code></td>
<td><code>Rc&lt;T&gt;</code></td>
<td>Reference-counted (single-threaded)</td>
</tr>
<tr>
<td><code>std::shared_ptr&lt;T&gt;</code> (thread-safe)</td>
<td><code>Arc&lt;T&gt;</code></td>
<td>Atomic reference-counted</td>
</tr>
<tr>
<td><code>new T</code></td>
<td><code>Box::new(T)</code></td>
<td>Heap allocation</td>
</tr>
<tr>
<td><code>delete ptr</code></td>
<td><code>drop(ptr)</code></td>
<td>Usually automatic</td>
</tr>
<tr>
<td><code>std::move(x)</code></td>
<td><code>x</code> (move is default)</td>
<td>Move is implicit in Rust on assignment; C++ move is an explicit cast
to rvalue reference</td>
</tr>
</tbody>
</table>
<p><strong>Key differences:</strong> - Rust moves by default; C++ copies
by default - Rust tracks lifetimes; C++ doesn’t - Rust prevents
use-after-move; C++ allows it (UB)</p>
<h3 id="references-and-borrowing">References and Borrowing</h3>
<table>
<colgroup>
<col style="width: 35%" />
<col style="width: 45%" />
<col style="width: 18%" />
</colgroup>
<thead>
<tr>
<th>C++ Pattern</th>
<th>Rust Equivalent</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>void f(T&amp; x)</code></td>
<td><code>fn f(x: &amp;mut T)</code></td>
<td>Mutable reference</td>
</tr>
<tr>
<td><code>void f(const T&amp; x)</code></td>
<td><code>fn f(x: &amp;T)</code></td>
<td>Immutable reference</td>
</tr>
<tr>
<td>Multiple <code>const T&amp;</code></td>
<td>Multiple <code>&amp;T</code></td>
<td>Allowed in both</td>
</tr>
<tr>
<td>Multiple mutable <code>T&amp;</code></td>
<td>One <code>&amp;mut T</code></td>
<td>C++ allows multiple mutable refs (but concurrent mutation is UB);
Rust prevents it</td>
</tr>
<tr>
<td>Return reference to local</td>
<td>Compile error</td>
<td>Rust prevents this</td>
</tr>
<tr>
<td>Dangling pointer</td>
<td>Compile error</td>
<td>Rust prevents this</td>
</tr>
</tbody>
</table>
<p><strong>Key differences:</strong> - Rust enforces aliasing XOR
mutability - Rust tracks reference lifetimes - Rust prevents dangling
references at compile time</p>
<h3 id="types-and-generics">Types and Generics</h3>
<table>
<thead>
<tr>
<th>C++ Pattern</th>
<th>Rust Equivalent</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>template&lt;typename T&gt;</code></td>
<td><code>fn f&lt;T&gt;()</code></td>
<td>Generic function</td>
</tr>
<tr>
<td><code>template&lt;typename T&gt; class C</code></td>
<td><code>struct S&lt;T&gt;</code></td>
<td>Generic struct</td>
</tr>
<tr>
<td>SFINAE</td>
<td>Trait bounds</td>
<td><code>fn f&lt;T: Trait&gt;()</code></td>
</tr>
<tr>
<td>Concepts (C++20)</td>
<td>Trait bounds</td>
<td>More explicit in Rust</td>
</tr>
<tr>
<td>Virtual functions</td>
<td>Trait objects</td>
<td><code>&amp;dyn Trait</code> or
<code>Box&lt;dyn Trait&gt;</code></td>
</tr>
<tr>
<td>Abstract base class</td>
<td>Trait</td>
<td>Define interface</td>
</tr>
<tr>
<td>Multiple inheritance</td>
<td>Multiple traits</td>
<td>Traits can be composed</td>
</tr>
<tr>
<td><code>static_cast&lt;T&gt;</code></td>
<td><code>as</code> or <code>From</code>/<code>Into</code></td>
<td>Type conversion</td>
</tr>
<tr>
<td><code>dynamic_cast&lt;T&gt;</code></td>
<td><code>downcast</code> (limited)</td>
<td>Less common in Rust</td>
</tr>
</tbody>
</table>
<p><strong>Key differences:</strong> - Rust traits are explicit; C++
templates are duck-typed - Rust checks trait bounds at definition; C++
checks at instantiation - Rust trait objects are explicit
(<code>dyn</code>); C++ virtual is implicit</p>
<h3 id="error-handling">Error Handling</h3>
<table>
<colgroup>
<col style="width: 35%" />
<col style="width: 45%" />
<col style="width: 18%" />
</colgroup>
<thead>
<tr>
<th>C++ Pattern</th>
<th>Rust Equivalent</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>throw Exception</code></td>
<td><code>return Err(e)</code></td>
<td>Errors are values</td>
</tr>
<tr>
<td><code>try { } catch { }</code></td>
<td><code>match result { Ok/Err }</code></td>
<td>Pattern matching</td>
</tr>
<tr>
<td>Exception propagation</td>
<td><code>?</code> operator</td>
<td>Explicit propagation</td>
</tr>
<tr>
<td><code>noexcept</code></td>
<td>No equivalent</td>
<td>Rust has no exceptions</td>
</tr>
<tr>
<td><code>std::optional&lt;T&gt;</code></td>
<td><code>Option&lt;T&gt;</code></td>
<td>Explicit null handling</td>
</tr>
<tr>
<td><code>nullptr</code></td>
<td><code>None</code></td>
<td>Part of <code>Option&lt;T&gt;</code>; Rust’s Option is more general
than C++ null pointers</td>
</tr>
<tr>
<td>Null pointer check</td>
<td><code>if let Some(x)</code></td>
<td>Compiler enforces</td>
</tr>
</tbody>
</table>
<p><strong>Key differences:</strong> - Rust has no exceptions—use
<code>Result&lt;T, E&gt;</code> - Errors are explicit in function
signatures - <code>Option&lt;T&gt;</code> makes null explicit</p>
<h3 id="mutability-and-const">Mutability and Const</h3>
<table>
<thead>
<tr>
<th>C++ Pattern</th>
<th>Rust Equivalent</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>T x</code> (mutable)</td>
<td><code>let mut x: T</code></td>
<td>Mutable variable</td>
</tr>
<tr>
<td><code>const T x</code></td>
<td><code>let x: T</code></td>
<td>Immutable by default</td>
</tr>
<tr>
<td><code>const T*</code></td>
<td><code>*const T</code></td>
<td>Pointer to const (unsafe)</td>
</tr>
<tr>
<td><code>T* const</code></td>
<td>N/A</td>
<td>Rust pointers don’t have this</td>
</tr>
<tr>
<td><code>const T&amp;</code></td>
<td><code>&amp;T</code></td>
<td>Immutable reference</td>
</tr>
<tr>
<td><code>mutable</code> keyword</td>
<td><code>Cell&lt;T&gt;</code> or <code>RefCell&lt;T&gt;</code></td>
<td>Interior mutability</td>
</tr>
</tbody>
</table>
<p><strong>Key differences:</strong> - Rust is immutable by default; C++
is mutable by default - Rust <code>mut</code> applies to bindings, not
types - Interior mutability is explicit in Rust</p>
<h3 id="concurrency">Concurrency</h3>
<table>
<colgroup>
<col style="width: 35%" />
<col style="width: 45%" />
<col style="width: 18%" />
</colgroup>
<thead>
<tr>
<th>C++ Pattern</th>
<th>Rust Equivalent</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>std::thread</code></td>
<td><code>std::thread</code></td>
<td>Similar API</td>
</tr>
<tr>
<td><code>std::mutex&lt;T&gt;</code></td>
<td><code>Mutex&lt;T&gt;</code></td>
<td>Mutex owns the data</td>
</tr>
<tr>
<td><code>std::lock_guard</code></td>
<td><code>MutexGuard</code></td>
<td>RAII lock guard</td>
</tr>
<tr>
<td><code>std::shared_ptr</code> + mutex</td>
<td><code>Arc&lt;Mutex&lt;T&gt;&gt;</code></td>
<td>Thread-safe shared state</td>
</tr>
<tr>
<td><code>std::atomic&lt;T&gt;</code></td>
<td><code>AtomicT</code></td>
<td>Lock-free atomics</td>
</tr>
<tr>
<td>Thread-local storage</td>
<td><code>thread_local!</code></td>
<td>Similar concept</td>
</tr>
<tr>
<td>Data race</td>
<td>Compile error</td>
<td>Prevented by type system</td>
</tr>
</tbody>
</table>
<p><strong>Key differences:</strong> - Rust prevents data races at
compile time - <code>Mutex&lt;T&gt;</code> owns the data it protects -
<code>Send</code> and <code>Sync</code> traits encode thread safety</p>
<h3 id="collections">Collections</h3>
<table>
<thead>
<tr>
<th>C++ Pattern</th>
<th>Rust Equivalent</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>std::vector&lt;T&gt;</code></td>
<td><code>Vec&lt;T&gt;</code></td>
<td>Dynamic array</td>
</tr>
<tr>
<td><code>std::array&lt;T, N&gt;</code></td>
<td><code>[T; N]</code></td>
<td>Fixed-size array</td>
</tr>
<tr>
<td><code>std::string</code></td>
<td><code>String</code></td>
<td>Owned string</td>
</tr>
<tr>
<td><code>std::string_view</code></td>
<td><code>&amp;str</code></td>
<td>String slice</td>
</tr>
<tr>
<td><code>std::map&lt;K, V&gt;</code></td>
<td><code>HashMap&lt;K, V&gt;</code></td>
<td>Hash map</td>
</tr>
<tr>
<td><code>std::set&lt;T&gt;</code></td>
<td><code>HashSet&lt;T&gt;</code></td>
<td>Hash set</td>
</tr>
<tr>
<td><code>std::unordered_map</code></td>
<td><code>HashMap</code></td>
<td>Rust’s default is unordered</td>
</tr>
<tr>
<td>Iterator</td>
<td>Iterator</td>
<td>Similar concept, more powerful</td>
</tr>
</tbody>
</table>
<p><strong>Key differences:</strong> - Rust iterators are zero-cost
abstractions - Rust prevents iterator invalidation - Rust strings are
UTF-8, not arbitrary bytes</p>
<h3 id="raii-and-destructors">RAII and Destructors</h3>
<table>
<thead>
<tr>
<th>C++ Pattern</th>
<th>Rust Equivalent</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td>Destructor <code>~T()</code></td>
<td><code>impl Drop for T</code></td>
<td>Automatic cleanup</td>
</tr>
<tr>
<td>RAII wrapper</td>
<td>Any type with <code>Drop</code></td>
<td>Mandatory, not opt-in</td>
</tr>
<tr>
<td><code>std::unique_ptr</code></td>
<td><code>Box&lt;T&gt;</code></td>
<td>Automatic deallocation</td>
</tr>
<tr>
<td>Manual <code>delete</code></td>
<td><code>drop(x)</code></td>
<td>Usually automatic</td>
</tr>
<tr>
<td>Destructor order</td>
<td>Same (reverse order)</td>
<td>Deterministic</td>
</tr>
</tbody>
</table>
<p><strong>Key differences:</strong> - RAII is mandatory in Rust, not
opt-in - Rust prevents use-after-move - <code>Drop</code> can’t fail (no
exceptions)</p>
<h3 id="common-patterns">Common Patterns</h3>
<table>
<colgroup>
<col style="width: 35%" />
<col style="width: 45%" />
<col style="width: 18%" />
</colgroup>
<thead>
<tr>
<th>C++ Pattern</th>
<th>Rust Equivalent</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td>Factory function</td>
<td>Associated function</td>
<td><code>T::new()</code></td>
</tr>
<tr>
<td>Method chaining</td>
<td>Method chaining</td>
<td>Same pattern</td>
</tr>
<tr>
<td>Builder pattern</td>
<td>Builder pattern</td>
<td>Common in Rust</td>
</tr>
<tr>
<td>PIMPL idiom</td>
<td><code>Box&lt;T&gt;</code></td>
<td>Hide implementation</td>
</tr>
<tr>
<td>Singleton</td>
<td><code>lazy_static!</code> or <code>OnceCell</code></td>
<td>Thread-safe initialization</td>
</tr>
<tr>
<td>Callback</td>
<td>Closure or <code>Fn</code> trait</td>
<td>Similar concept</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="takeaways-for-c-developers-14">Takeaways for C++ Developers</h2>
<p><strong>Direct translations:</strong> -
<code>unique_ptr&lt;T&gt;</code> → <code>Box&lt;T&gt;</code> -
<code>shared_ptr&lt;T&gt;</code> → <code>Rc&lt;T&gt;</code>
(single-threaded) or <code>Arc&lt;T&gt;</code> (multi-threaded) -
<code>const T&amp;</code> → <code>&amp;T</code> - <code>T&amp;</code> →
<code>&amp;mut T</code> - <code>std::vector&lt;T&gt;</code> →
<code>Vec&lt;T&gt;</code> - <code>std::optional&lt;T&gt;</code> →
<code>Option&lt;T&gt;</code></p>
<p><strong>Requires restructuring:</strong> - Multiple mutable
references → Use <code>RefCell</code> or restructure - Exceptions → Use
<code>Result&lt;T, E&gt;</code> - Null pointers → Use
<code>Option&lt;T&gt;</code> - Virtual functions → Use trait objects
(<code>&amp;dyn Trait</code>) - Templates → Use generics with trait
bounds</p>
<p><strong>Doesn’t exist in Rust:</strong> - Raw
<code>new</code>/<code>delete</code> (use <code>Box::new</code> or
allocators) - Exceptions (use <code>Result</code>) - Null pointers (use
<code>Option</code>) - Inheritance (use composition and traits) -
Implicit conversions (use <code>From</code>/<code>Into</code>
traits)</p>
<p><strong>Rust has, C++ doesn’t:</strong> - Lifetime annotations
(<code>'a</code>) - Pattern matching (<code>match</code>) -
<code>?</code> operator for error propagation - Trait objects
(<code>dyn Trait</code>) - Compile-time data race prevention</p>
<p><strong>Mental model adjustments:</strong> - Think “ownership” not
“pointer” - Think “borrow” not “reference” - Think “trait” not
“interface” or “template” - Think “Result” not “exception” - Think
“Option” not “null”</p>
<p><strong>When stuck:</strong> - If the borrow checker complains,
you’re trying to alias and mutate - If lifetimes are confusing, draw the
ownership graph - If traits are unclear, think “explicit interface” - If
errors are verbose, read the first line and the suggestion - If cloning
seems wrong, it might be right—explicit cost is better than hidden
bugs</p>
<p>This cheat sheet is a starting point. The patterns will become
intuitive with practice.</p>
<hr />
<h1 id="acknowledgments-1">Acknowledgments</h1>
<p>This book exists because of work done by others.</p>
<p>The Rust project’s documentation—particularly <em>The Rust
Programming Language</em> by Steve Klabnik and Carol Nichols—provided
the foundation. The Rust compiler’s error messages taught more than any
tutorial could.</p>
<p>The C++ community’s decades of experience with memory safety, RAII,
and zero-cost abstractions informed every comparison in this book. The
problems Rust solves are problems C++ developers identified and
documented long before Rust existed.</p>
<p>Engineers who reviewed early drafts caught technical errors and
unclear explanations. Their skepticism improved the book.</p>
<p>The tools that made this possible: Rust’s compiler, Cargo,
rust-analyzer, and the standard library documentation. Markdown for
writing. Git for version control.</p>
<p>To the developers who’ve debugged enough use-after-free bugs to
appreciate what Rust prevents: this book is for you.</p>
<h2 id="about-the-author">About the Author</h2>
<p>Robin George Koshy is a Senior Software Engineer with <strong>12+
years of experience</strong> building systems-level C++ software in the
automotive domain. His career includes work at Bosch and MathWorks,
where he focused on production systems where correctness, performance,
and long-term maintainability matter more than elegance on a
whiteboard.</p>
<p>His work spans core C++ infrastructure, real-time and concurrent
systems, signal processing pipelines, and applied AI/ML—often at the
intersection of hardware, data, and safety-critical software. Like many
C++ engineers in automotive, his day-to-day work involved explicit
memory management, complex ownership conventions, defensive coding
patterns, and debugging failures that only surfaced in production.</p>
<p>Learning Rust required unlearning assumptions that had been
reinforced over years of “working” C++ code. The borrow checker rejected
patterns that were familiar, idiomatic, and widely accepted—yet often
fragile. The frustration was real, but so was the realization that many
of those patterns relied on discipline rather than guarantees.</p>
<p>This book documents that learning process—not as a conversion story,
but as a translation guide. Rust and C++ solve similar systems problems
under different constraints and with different trade-offs. Understanding
Rust requires mapping existing C++ mental models to a language that
encodes invariants directly into the type system.</p>
<p>The goal was to write the book that didn’t exist when learning Rust:
one that assumes deep systems programming experience and focuses on
<em>why</em> Rust works the way it does, not just <em>how</em> to use
it.</p>
<p>If you’ve spent years writing C++ and are seriously evaluating Rust,
this book is that map.</p>
<h1 id="further-reading">Further Reading</h1>
<p>This book teaches mental models, not comprehensive Rust. Here’s where
to go next.</p>
<hr />
<h2 id="official-rust-resources">Official Rust Resources</h2>
<p><strong>The Rust Programming Language</strong> (The Book)<br />
https://doc.rust-lang.org/book/<br />
The official introduction to Rust. Comprehensive, well-written, assumes
no systems programming background. Read this for syntax and standard
library details this book skipped.</p>
<p><strong>Rust by Example</strong><br />
https://doc.rust-lang.org/rust-by-example/<br />
Code-first learning. Useful for seeing patterns in action without
lengthy explanations.</p>
<p><strong>The Rustonomicon</strong><br />
https://doc.rust-lang.org/nomicon/<br />
The unsafe Rust guide. Read this if you’re implementing low-level data
structures or interfacing with C. Assumes you understand why unsafe
exists.</p>
<p><strong>Rust Standard Library Documentation</strong><br />
https://doc.rust-lang.org/std/<br />
The reference. Well-documented, with examples. Use this when you need to
know what methods a type provides.</p>
<p><strong>Rust Reference</strong><br />
https://doc.rust-lang.org/reference/<br />
The language specification. Dry, precise, complete. Read this when you
need to know exactly what the language guarantees.</p>
<hr />
<h2 id="specialized-topics">Specialized Topics</h2>
<p><strong>Asynchronous Programming in Rust</strong><br />
https://rust-lang.github.io/async-book/<br />
Covers async/await, futures, and the async runtime ecosystem. Essential
if you’re building network services or I/O-heavy applications.</p>
<p><strong>The Cargo Book</strong><br />
https://doc.rust-lang.org/cargo/<br />
Everything about Rust’s build system and package manager. Read this when
you need to configure builds, manage dependencies, or publish
crates.</p>
<p><strong>Rust API Guidelines</strong><br />
https://rust-lang.github.io/api-guidelines/<br />
Best practices for designing Rust APIs. Useful if you’re writing
libraries others will use.</p>
<hr />
<h2 id="c-to-rust-transition">C++ to Rust Transition</h2>
<p><strong>Rust for C++ Programmers</strong> (GitHub)<br />
https://github.com/nrc/r4cppp<br />
Nick Cameron’s guide. Covers similar ground to this book with different
examples and explanations. Worth reading for alternative
perspectives.</p>
<p><strong>Comparing Rust and C++</strong> (Various blog posts)<br />
Search for “Rust vs C++” on engineering blogs. Many experienced C++
developers have documented their learning process. The best posts focus
on trade-offs, not advocacy.</p>
<hr />
<h2 id="what-not-to-read">What Not to Read</h2>
<p>Avoid: - “Why Rust is better than X” articles—they oversimplify -
Tutorials that skip explaining why the borrow checker exists - Advocacy
pieces that ignore Rust’s costs - Anything that promises Rust will make
you a better programmer</p>
<p>Rust is a tool. Learn it by using it, not by reading about it.</p>
<hr />
<h2 id="next-steps">Next Steps</h2>
<ol type="1">
<li>Write Rust code. Start small: command-line tools, parsers, file
processors.</li>
<li>Fight the borrow checker. Understand why it rejects your code.</li>
<li>Read the compiler errors. They’re teaching you.</li>
<li>Refactor working code. See how Rust’s guarantees enable confident
changes.</li>
<li>Contribute to an existing Rust project. See how real codebases are
structured.</li>
</ol>
<p>The mental models in this book are a foundation. The rest is
practice.</p>
</body>
</html>
