# The Rust Odyssey
## A C++ Developer’s Journey

This document defines the working table of contents.
Chapter titles may evolve, but the overall arc should remain stable.

---

## Act I — Orientation: Resetting Mental Models

**Goal:** Reframe expectations without insulting the reader.

1. Why Rust Exists (From a C++ Failure Modes Perspective)
2. Rust Is Not “Safer C++”
3. Ownership, Control, and Responsibility
4. Why the Borrow Checker Feels Hostile

---

## Act II — Mapping Core Concepts (C++ → Rust)

**Goal:** Translate familiar ideas and expose where intuition breaks.

5. RAII vs `Drop`: Same Outcome, Different Constraints  
6. Copy, Move, and Ownership: C++ Semantics vs Rust Guarantees  
7. References, Borrowing, and Aliasing  
8. `const`, Mutability, and Interior Mutability  
9. Templates vs Traits: Power, Limits, and Intent  
10. Enums, Variants, and Exhaustiveness  
11. Error Handling: Exceptions vs `Result`  
12. Lifetimes as Design Constraints (Not Annotations)

---

## Act III — Systems Programming, Rust Style

**Goal:** Apply Rust to real systems problems C++ developers care about.

13. File I/O, Buffers, and Zero-Copy Reading  
14. Designing Parsers with Ownership in Mind  
15. Unsafe Rust: What It Actually Means  
16. Concurrency: Threads, Mutexes, and Message Passing  
17. FFI: Calling C from Rust and Rust from C++  
18. Testing and Fuzzing: Catching Bugs Earlier

---

## Act IV — Trade-offs, Reality, and Adoption

**Goal:** Be honest about costs and integration.

19. Compile Times, Tooling, and Developer Experience  
20. Where Rust Hurts Productivity  
21. When C++ Is Still the Better Choice  
22. Introducing Rust into an Existing C++ Codebase  
23. Rust as a Long-Term Systems Language

---

## Epilogue

24. Choosing Your Tools Deliberately
